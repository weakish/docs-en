{% import "views/_helper.njk" as docs %}
{% macro regex(useSingleQuotes = false) -%}
^((?!ticket).)*&dollar;{% if useSingleQuotes == true %}&apos;{% else %}&quot;{% endif %}
{%- endmacro %}

# LeanStorage {{platform_name}} Guide

The LeanStorage {{platform_name}} SDK can be used to persist and query data in LeanCloud. The code below shows how you can create an object and store it into the cloud:

{% if platform_name === "Objective-C" %}
```objc
// Create an object
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// Set values of fields
[todo setObject:@"R&D Weekly Meeting"        forKey:@"title"];
[todo setObject:@"All team members, Tue 2pm" forKey:@"content"];

// Save the object to the cloud
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // Execute any logic that should take place after the object is saved
        NSLog(@"Object saved. objectId: %@", todo.objectId);
    } else {
        // Execute any logic that should take place if the save fails
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Declare a class
var Todo = AV.Object.extend('Todo');

// Create an object
var todo = new Todo();

// Set values of fields
todo.set('title',   'R&D Weekly Meeting');
todo.set('content', 'All team members, Tue 2pm');

// Save the object to the cloud
todo.save().then(function (todo) {
  // Execute any logic that should take place after the object is saved
  console.log('Object saved. objectId: ' + todo.id);
}, function (error) {
  // Execute any logic that should take place if the save fails
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Declare a class
Todo = leancloud.Object.extend('Todo')

# Create an object
todo = Todo()

# Set values of fields
todo.set('title',   'R&D Weekly Meeting')
todo.set('content', 'All team members, Tue 2pm')

# Save the object to the cloud
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Create an object
$todo = new LeanObject("Todo");

// Set values of fields
$todo->set("title",   "R&D Weekly Meeting");
$todo->set("content", "All team members, Tue 2pm");

// Save the object to the cloud
$todo->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Create an object
AVObject todo = new AVObject("Todo");

// Set values of fields
todo.put("title",   "R&D Weekly Meeting");
todo.put("content", "All team members, Tue 2pm");

// Save the object to the cloud
todo.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // Execute any logic that should take place after the object is saved
        System.out.println("Object saved. objectId: " + todo.getObjectId());
    }
    public void onError(Throwable throwable) {
        // Execute any logic that should take place if the save fails
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // Create an object
    let todo = LCObject(className: "Todo")

    // Set values of fields
    try todo.set("title",   value: "R&D Weekly Meeting")
    try todo.set("content", value: "All team members, Tue 2pm")

    // Save the object to the cloud
    _ = todo.save { result in
        switch result {
        case .success:
            // Execute any logic that should take place after the object is saved
            break
        case .failure(error: let error):
            // Execute any logic that should take place if the save fails
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% call docs.noteWrap() %}
The SDK designed for each language interacts with the same [REST API](rest_api.html) via HTTPS, offering fully functional interfaces for you to manipulate the data in the cloud.
{% endcall %}

## Installing SDK

{% if platform_name === "Objective-C" %}
See [How to Install Objective-C SDK](sdk_setup-objc.html).
{% endif %}
{% if platform_name === "JavaScript" %}
See [How to Install JavaScript SDK](sdk_setup-js.html).
{% endif %}
{% if platform_name === "Python" %}
See [How to Install Python SDK](sdk_setup-python.html).
{% endif %}
{% if platform_name === "PHP" %}
See [How to Install PHP SDK](sdk_setup-php.html).
{% endif %}
{% if platform_name === "Java" %}
See [How to Install Java SDK](sdk_setup-java.html).
{% endif %}
{% if platform_name === "Swift" %}
See [How to Install Swift SDK](sdk_setup-swift.html).
{% endif %}

{% if platform_name === "JavaScript" %}
## Web Security

If you are using our JavaScript SDK in your browser based application, you must configure **whitelist domains** in your app's [Dashboard > Settings > Security](https://console.leancloud.app/app.html?appid={{appid}}#/security) before you deploy it to a production environment. Once set up, our backend will only accept requests sent from domains in the whitelist, which prevents unauthorized usage or access to your cloud data on a certain level.

However, since your app is exposed to the Internet, simply setting up whitelist domains can't totally guarantee the security of your app. LeanCloud offers a variety of ways to help you secure your apps as well as the data stored within them. The following articles give you the necessary information you need to know regarding app security.

- [Data and Security](data_security.html)
- [ACL Guide](acl-guide.html)
{% endif %}

## Objects

### `{{ baseObjectName }}`

Storing data on LeanCloud is built around `{{ baseObjectName }}`. Each `{{ baseObjectName }}` contains key-value pairs of JSON-compatible data. This data is schema free, which means that you don't need to specify ahead of time what keys exist on each `{{ baseObjectName }}`. Simply set whatever key-value pairs you want, and our backend will store it.

For example, the `{{ baseObjectName }}` storing a simple todo item may contain the following data:

```json
title:      "Email Linda to Confirm Appointment",
isComplete: false,
priority:   2,
tags:       ["work", "sales"]
```

{# Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays, objects, and anything that can be JSON-encoded. #}

### Data Types

`{{ baseObjectName }}` supports a wide range of data types to be used for each field, including common ones like `String`, `Number`, `Boolean`, `Object`, `Array`, `Date`, and `null`. You can nest objects in JSON format to store more structured data within a single `Object` or `Array` field.

Special data types supported by `{{ baseObjectName }}` include `Pointer` and `File`, which are used to store a reference to another `{{ baseObjectName }}` and binary data respectively.

`{{ baseObjectName }}` also supports `GeoPoint`, a special data type you can use to store location-based data. See [GeoPoints](#geopoints) for more details.

Some examples:

{% if platform_name === "Objective-C" %}
```objc
// Basic objects
NSNumber     *boolean    = @(YES);
NSNumber     *number     = [NSNumber numberWithInt:2018];
NSString     *string     = [NSString stringWithFormat:@"%@ Top Hit Songs", number];
NSDate       *date       = [NSDate date];
NSData       *data       = [@"Hello world!" dataUsingEncoding:NSUTF8StringEncoding];
NSArray      *array      = [NSArray arrayWithObjects: string, number, nil];
NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys: number, @"number", string, @"string", nil];

// Create an object
AVObject *testObject = [AVObject objectWithClassName:@"TestObject"];
[testObject setObject:boolean    forKey:@"testBoolean"];
[testObject setObject:number     forKey:@"testInteger"];
[testObject setObject:string     forKey:@"testString"];
[testObject setObject:date       forKey:@"testDate"];
[testObject setObject:data       forKey:@"testData"];
[testObject setObject:array      forKey:@"testArray"];
[testObject setObject:dictionary forKey:@"testDictionary"];
[testObject saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Declare a class
var TestObject = AV.Object.extend('TestObject');

// Basic objects
var number = 2018;
var string = number + ' Top Hit Songs';
var date   = new Date();
var array  = [string, number];
var object = {
  number: number,
  string: string
};

// An AV.Object with another class
var pointer = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');

// Create an object
var testObject = new TestObject();
testObject.set('testNumber',  number);
testObject.set('testString',  string);
testObject.set('testDate',    date);
testObject.set('testArray',   array);
testObject.set('testObject',  object);
testObject.set('testNull',    null);
testObject.set('testPointer', pointer);
testObject.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

# Declare a class
TestObject = leancloud.Object.extend('TestObject')

# Create an object
test_object = TestObject()
test_object.set('testString',  'work')
test_object.set('testInt',     108)
test_object.set('testFloat',   1.890)
test_object.set('testBoolean', True)
test_object.set('testList',    [1, 2, [3, 4, 'string']])
test_object.set('testDict',    {'item1': 12, 'item2': 'string', 'item3': [1, 2, '3']})
test_object.set('testDate',    datetime.now())
test_object.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Basic objects
$bool       = true;
$number     = 2018;
$string     = $number . " Top Hit Songs";
$date       = new \DateTime();
$bytesArray = Bytes::createFromBase64Data(base64_encode("Hello world!"));

// Create an object
$testObject = new LeanObject("TestObject");
$testObject->set("testBoolean", $bool);
$testObject->set("testInteger", $number);
$testObject->set("testString",  $string);
$testObject->set("testData",    $bytesArray);
$testObject->set("testDate",    $date);
$testObject->set("testArray",   array($string, $number));
$testObject->set("testAssociativeArray",
                 array("number" => $number,
                       "string" => $string));
$testObject->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Basic objects
boolean bool = true;
int number = 2018;
String string = number + " Top Hit Songs";
Date date = new Date();
byte[] data = "Hello world!".getBytes();
ArrayList<Object> arrayList = new ArrayList<>();
arrayList.add(number);
arrayList.add(string);
HashMap<Object, Object> hashMap = new HashMap<>();
hashMap.put("number", number);
hashMap.put("string", string);

// Create an object
AVObject testObject = new AVObject("TestObject");
testObject.put("testBoolean",   bool);
testObject.put("testInteger",   number);
testObject.put("testDate",      date);
testObject.put("testData",      data);
testObject.put("testArrayList", arrayList);
testObject.put("testHashMap",   hashMap);
testObject.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// All LC data types satisfies `LCValue` protocol.

let number       : LCNumber       = 42
let bool         : LCBool         = true
let string       : LCString       = "foo"
let dictionary   : LCDictionary   = LCDictionary(["name": string, "count": number])
let array        : LCArray        = LCArray([number, bool, string])
let emptyData    : LCData         = LCData(Data())
let currentDate  : LCDate         = LCDate(Date())
let null         : LCNull         = LCNull()
let geoPoint     : LCGeoPoint     = LCGeoPoint(latitude: 45, longitude: -45)
let acl          : LCACL          = LCACL()
let object       : LCObject       = LCObject()
let relation     : LCRelation     = object.relationForKey("elements")
let user         : LCUser         = LCUser()
let file         : LCFile         = LCFile()
let installation : LCInstallation = LCInstallation()

// Convert LC data types to Swift standard types:
let swiftInt:        Int?              = number.intValue
let swiftDouble:     Double            = number.value
let swiftBool:       Bool              = bool.value
let swiftString:     String            = string.value
let swiftDictionary: [String: LCValue] = dictionary.value
let swiftArray:      [LCValue]         = array.value

// Construct LC data types:
let object       : LCObject       = LCObject()
let relation     : LCRelation     = object.relationForKey("elements") // LCRelation does not imherit LCObject.
let user         : LCUser         = LCUser()
let file         : LCFile         = LCFile()
let installation : LCInstallation = LCInstallation()

/* Setters for LC data types: */

// 1. `set(_:value:)`, this form will check if `value` is valid
do {
    try object.set("number", value: 42)
    try object.set("number", value: LCNumber(42))
} catch {
    print(error)
}

// 2. subscript, this form will not check if `value` is valid
object["number"] = 42.lcValue
object["number"] = LCNumber(42)

/* Getters for LC data types */

// 1. `get(_:)`
let getNumber1: LCNumber? = object.get("number") as? LCNumber

// 2. subscript
let getNumber2: LCNumber? = object["number"] as? LCNumber
```
{% endif %}

We do not recommend storing large pieces of binary data like images or documents with `{{ baseObjectName }}`{% if platform_name === "Objective-C" %} using `NSData`{% endif %}{% if platform_name === "JavaScript" %}{% endif %}{% if platform_name === "Python" %} using `byte[]`{% endif %}{% if platform_name === "PHP" %} using `Bytes`{% endif %}{% if platform_name === "Java" %} using `byte[]`{% endif %}{% if platform_name === "Swift" %} using `LCData`{% endif %}. The size of each `{{ baseObjectName }}` should not exceed **128 kilobytes**. We recommend using `{{ fileObjectName }}` for storing images, documents, and other types of files. To do so, create `{{ fileObjectName }}` objects and assign them to fields of `{{ baseObjectName }}`. See [Files](#files) for details.

{% call docs.noteWrap() %}
Keep in mind that our backend stores dates in UTC format and the SDK will convert them to local times upon retrieval.

The date values displayed in your app's [Dashboard > LeanStorage > Data](https://console.leancloud.app/data.html?appid={{appid}}#/) are also converted to match your operating system's time zone. The only exception is that when you retrieve these date values through our [REST API](rest_api.html), they will remain in UTC format. You can manually convert them using appropriate time zones when necessary.
{% endcall %}

To learn about how you can protect the data stored on LeanCloud, see [Data and Security](data_security.html).

### Creating Objects

The code below creates a new instance of `{{ baseObjectName }}` with class `Todo`:

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// You can also use this equivalent way
AVObject *todo = [[AVObject alloc] initWithClassName:@"Todo"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Create a new subclass of AV.Object
var Todo = AV.Object.extend('Todo');

// Create a new instance of that class
var todo = new Todo();

// You can also use the AV.Object constructor directly
new AV.Object('Todo');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Create a new subclass of leancloud.Object
Todo = leancloud.Object.extend('Todo')

# Create a new instance of that class
todo = Todo()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");

// You can also use this equivalent way
$todo = LeanObject::create("Todo");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = new AVObject("Todo");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
```
{% endif %}

The constructor takes class name as a parameter so that the cloud knows the class you are using to create the object. A class in LeanCloud is comparable to a table in a relational database. A class name starts with a letter and can only contain numbers, letters, and underscores.

{% if platform_name === "JavaScript" %}
{% call docs.noteWrap() %}
If you keep seeing `Maximum call stack size exceeded` exception in your log, chances are `AV.Object.extend` had been called using the same class name more than once within a loop or a callback. To resolve such issue, either move it out of the loop or the callback to make sure it won't be over-instantiated, or switch to JavaScript SDK 1.4 or higher which handles the problem automatically.
{% endcall %}

If you're using ES6 in your codebase, you can subclass `AV.Object` with the `extends` keyword. However, when using `extends`, the SDK is not automatically aware of your subclasses. You will need to register the subclasses with the SDK:

```js
class Todo extends AV.Object {
  // More properties and methods
}

// Register the subclass
AV.Object.register(Todo);
```

After doing this, you will be able to add additional methods and properties to your subclasses of `AV.Object`.
{% endif %}

### Saving Objects

The following code saves a new object with class `Todo` to the cloud:

{% if platform_name === "Objective-C" %}
```objc
// Create an object
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// Set values of fields
[todo setObject:@"Sign up for Marathon" forKey:@"title"];
[todo setObject:@2 forKey:@"priority"];

// Save the object to the cloud
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // Execute any logic that should take place after the object is saved
        NSLog(@"Object saved. objectId: %@", todo.objectId);
    } else {
        // Execute any logic that should take place if the save fails
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Declare a class
var Todo = AV.Object.extend('Todo');

// Create an object
var todo = new Todo();

// Set values of fields
todo.set('title', 'Sign up for Marathon');
todo.set('priority', 2);

// Save the object to the cloud
todo.save().then(function (todo) {
  // Execute any logic that should take place after the object is saved
  console.log('Object saved. objectId: ' + todo.id);
}, function (error) {
  // Execute any logic that should take place if the save fails
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Declare a class
Todo = leancloud.Object.extend('Todo')

# Create an object
todo = Todo()

# Set values of fields
todo.set('title', 'Sign up for Marathon')
todo.set('priority', 2)

# Save the object to the cloud
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Create an object
$todo = new LeanObject("Todo");

// Set values of fields
$todo->set("title", "Sign up for Marathon");
$todo->set("priority", 2);

// Save the object to the cloud
$todo->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Create an object
AVObject todo = new AVObject("Todo");

// Set values of fields
todo.put("title", "Sign up for Marathon");
todo.put("priority", 2);

// Save the object to the cloud
todo.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // Execute any logic that should take place after the object is saved
        System.out.println("Object saved. objectId: " + todo.getObjectId());
    }
    public void onError(Throwable throwable) {
        // Execute any logic that should take place if the save fails
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // Create an object
    let todo = LCObject(className: "Todo")

    // Set values of fields
    try todo.set("title", value: "Sign up for Marathon")
    try todo.set("priority", value: 2)

    // Save the object to the cloud
    _ = todo.save { result in
        switch result {
        case .success:
            // Execute any logic that should take place after the object is saved
            break
        case .failure(error: let error):
            // Execute any logic that should take place if the save fails
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

To make sure the object is successfully saved, take a look at [Dashboard > LeanStorage > Data > `Todo`](https://console.leancloud.app/data.html?appid={{appid}}#/Todo) in your app. You should see a new entry of data with something like this when you click on its `objectId`:

```json
{
  "title":     "Sign up for Marathon",
  "priority":  2,
  "ACL": {
    "*": {
      "read":  true,
      "write": true
    }
  },
  "objectId":  "582570f38ac247004f39c24b",
  "createdAt": "2017-11-11T07:19:15.549Z",
  "updatedAt": "2017-11-11T07:19:15.549Z"
}
```

{% call docs.noteWrap() %}
You don't have to create or set up a new class called `Todo` in [Dashboard > LeanStorage > Data](https://console.leancloud.app/data.html?appid={{appid}}#/) before running the code above. If the class doesn't exist, it will be automatically created.
{% endcall %}

There are several built-in fields that are provided by default which you don't need to specify in your code:

Built-in Field | Type | Description
--- | --- | ---
`objectId` | `{% if platform_name === "Objective-C" %}NSString{% endif %}{% if platform_name === "JavaScript" %}String{% endif %}{% if platform_name === "Python" %}str{% endif %}{% if platform_name === "PHP" %}String{% endif %}{% if platform_name === "Java" %}String{% endif %}{% if platform_name === "Swift" %}LCString{% endif %}` | A unique identifier for each saved object.
`ACL` | `{% if platform_name === "Objective-C" %}AVACL{% endif %}{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Java" %}AVACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}` | Access Control List, a special object defining the read and write permissions of other people.
`createdAt` | `{% if platform_name === "Objective-C" %}NSDate{% endif %}{% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Java" %}Date{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}` | The time the object was created.
`updatedAt` | `{% if platform_name === "Objective-C" %}NSDate{% endif %}{% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Java" %}Date{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}` | The time the object was last modified.

Each of these fields is filled in by the cloud automatically and doesn't exist on the local `{{ baseObjectName }}` until a save operation has been completed.

Field names, or **keys**, can only contain letters, numbers, and underscores. A custom key can neither start with double underscores `__`, nor be identical to any system reserved words or built-in field names (`ACL`, `className`, `createdAt`, `objectId`, and `updatedAt`) regardless of letter cases.

**Values** can be strings, numbers, booleans, or even arrays and dictionaries — anything that can be JSON-encoded. See [Data Types](#data-types) for more information.

We recommend that you adopt CamelCase naming convention to `NameYourClassesLikeThis` and `nameYourKeysLikeThis`, which keeps your code more readable.

### Retrieving Objects

If `{{ baseObjectName }}` is already in the cloud, you can retrieve it using its `objectId` with the following code:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query getObjectInBackgroundWithId:@"582570f38ac247004f39c24b" block:^(AVObject *todo, NSError *error) {
    // todo is the instance of the Todo object with objectId 582570f38ac247004f39c24b
    NSString *title    = todo[@"title"];
    int priority       = [[todo objectForKey:@"priority"] intValue];

    // Acquire special properties
    NSString *objectId = todo.objectId;
    NSDate *updatedAt  = todo.updatedAt;
    NSDate *createdAt  = todo.createdAt;
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then(function (todo) {
  // todo is the instance of the Todo object with objectId 582570f38ac247004f39c24b
  var title     = todo.get('title');
  var priority  = todo.get('priority');

  // Acquire special properties
  var objectId  = todo.id;
  var updatedAt = todo.updatedAt;
  var createdAt = todo.createdAt;
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
todo = query.get('582570f38ac247004f39c24b')

# todo is the instance of the Todo object with objectId 582570f38ac247004f39c24b
title      = todo.get('title')
priority   = todo.get('priority')

# Acquire special properties.
object_id  = todo.id
update_at  = todo.updated_at
created_at = todo.created_at
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$todo = $query->get("582570f38ac247004f39c24b");

// Acquire special properties.
$objectId = $todo->getObjectId();
$updatedAt = $todo->getUpdatedAt();
$createdAt = $todo->getCreatedAt();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.getInBackground("582570f38ac247004f39c24b").subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // todo is the instance of the Todo object with objectId 582570f38ac247004f39c24b
        String title    = todo.getString("title");
        int priority    = todo.getInt("priority");

        // Acquire special properties
        String objectId = todo.getObjectId();
        Date updatedAt  = todo.getUpdatedAt();
        Date createdAt  = todo.getCreatedAt();
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let _ = query.get("582570f38ac247004f39c24b") { (result) in
    switch result {
    case .success(object: let todo):
        // todo is the instance of the Todo object with objectId 582570f38ac247004f39c24b
        let title     = todo.get("title")
        let priority  = todo.get("priority")

        // Acquire special properties
        let objectId  = todo.objectId
        let updatedAt = todo.updatedAt
        let createdAt = todo.createdAt
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Swift" %}
After retrieving an object, you can use the `get` method to acquire the data stored in its fields. Be aware that `objectId`, `updatedAt`, and `createdAt` are 3 special properties that cannot be retrieved using the `get` method or modified with the `set` method. Each of these fields is filled in by the cloud only, so they don't exist on `{{ baseObjectName }}` until a save operation has been completed.
{% endif %}

If you try to access a field or property that doesn't exist, the SDK will not raise an error. Instead, it will return `{% if platform_name in ["Objective-C", "Swift"] %}nil{% endif %}{% if platform_name === "JavaScript" %}undefined{% endif %}{% if platform_name === "Python" %}None{% endif %}{% if platform_name in ["Java", "PHP"] %}null{% endif %}.

{% if platform_name === "JavaScript" %}
Sometimes you may want to get all the fields back at one time without calling `get` on each field of the object. This could be helpful when you implement data binding. To do so, call `toJSON` on `AV.Object`:

```js
var query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then(function (todo) {
  console.log(todo.toJSON());
  // {
  //   createdAt: "2017-03-08T11:25:07.804Z",
  //   objectId: "582570f38ac247004f39c24b",
  //   priority: 2,
  //   title: "R&D Weekly Meeting",
  //   updatedAt: "2017-03-08T11:25:07.804Z"
  // }
});
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" or platform_name === "Swift" %}
#### Refreshing Objects

If you need to refresh a local object with the latest version of it in the cloud, call the `{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Java" %}fetchInBackground{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` method on it:
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo fetchInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    // todo is refreshed
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch().then(function (todo) {
  // todo is refreshed
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.fetch()
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.fetchInBackground().subscribe(new Observable<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // todo is refreshed
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.fetch { result in
    switch result {
    case .success:
        // todo is refreshed
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" %}
Keep in mind that **any unsaved changes made to the object prior to calling `{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Java" %}fetchInBackground{% endif %}` will be discarded**. To avoid this, you have the option to provide **a list of keys** when calling the method so that only the fields being specified are retrieved and refreshed (including special built-in fields such as `objectId`, `createdAt`, and `updatedAt`). Changes made to other fields will remain intact.
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
NSArray *keys = [NSArray arrayWithObjects:@"priority", @"location", nil];
[todo fetchInBackgroundWithKeys:keys block:^(AVObject *todo, NSError *error) {
    // Only priority and location will be retrieved and refreshed
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch({
  keys: 'priority, location'
}).then(function (todo) {
  // Only priority and location will be retrieved and refreshed
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
String keys = "priority, location";
todo.fetchInBackground(keys).subscribe(new Observable<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // Only priority and location will be retrieved and refreshed
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}

{# After the object is refreshed successfully, its `updatedAt` value will be updated on the client. The cloud won't have this new value until the next save or fetch happens, thus some network bandwidth can be saved out of it. #}

{# With that in mind, let's make it more fun. Let's build a new `AV.Object` locally from scratch with an objectId, and retrieve more field values associated with this object from the cloud without using `AV.Query`. #}

### Updating Objects

To update an existing object, assign the new data to each field and call the `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}` method. For example:

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo setObject:@"Weekly meeting has been rescheduled to Wed 3pm for this week." forKey:@"content"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.set('content', 'Weekly meeting has been rescheduled to Wed 3pm for this week.');
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.set('content', 'Weekly meeting has been rescheduled to Wed 3pm for this week.')
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->set("content", 'Weekly meeting has been rescheduled to Wed 3pm for this week.');
$todo->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.put("content", "Weekly meeting has been rescheduled to Wed 3pm for this week.");
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
do {
    let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
    try todo.set("content", value: "Weekly meeting has been rescheduled to Wed 3pm for this week.")
    todo.save { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

LeanCloud automatically figures out which data has changed and only the fields with changes will be sent to the cloud. The fields you didn't update will remain intact.

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" %}
#### Updating Data Conditionally

By passing in a `query` option when saving, you can specify conditions on the save operation so that the object can be updated atomically only when those conditions are met. If no object matches the conditions, the cloud will return error `305` to indicate that there was no update taking place.

For example, in the class `Account` there is a field called `balance`, and there are multiple incoming requests that want to modify this field. Since an account cannot have a negative balance, we can only allow a request to update the balance when the amount requested is lower than or equal to the balance:
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *account = [AVObject objectWithClassName:@"Account" objectId:@"5745557f71cfe40068c6abe0"];
// Atomically decrease balance by 100
NSInteger amount = -100;
[account incrementKey:@"balance" byAmount:@(amount)];
// Add the condition
AVQuery *query = [[AVQuery alloc] init];
[query whereKey:@"balance" greaterThanOrEqualTo:@(-amount)];
AVSaveOption *option = [[AVSaveOption alloc] init];
option.query = query;
// Return the latest data in the cloud upon completion.
// All the fields will be returned if the object is new,
// otherwise only fields with changes will be returned.
option.fetchWhenSave = YES;
[account saveInBackgroundWithOption:option block:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
        NSLog(@"Balance: %@", account[@"balance"]);
    } else if (error.code == 305) {
        NSLog(@"Insufficient balance. Operation failed!");
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var account = AV.Object.createWithoutData('Account', '5745557f71cfe40068c6abe0');
// Atomically decrease balance by 100
var amount = -100;
account.increment('balance', amount);
account.save(null, {
  // Add the condition
  query: new AV.Query('Account').greaterThanOrEqualTo('balance', -amount),
  // Return the latest data in the cloud upon completion.
  // All the fields will be returned if the object is new,
  // otherwise only fields with changes will be returned.
  fetchWhenSave: true
}).then(function (account) {
  console.log('Balance: ', account.get('balance'));
}, function (error) {
  if (error.code === 305) {
    console.error('Insufficient balance. Operation failed!');
  }
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Account = leancloud.Object.extend('Account')
account = Account.create_without_data('5745557f71cfe40068c6abe0')
# Atomically decrease balance by 100
amount = -100
account.increment('balance', amount)
# Add the condition
where = Account.query.greater_than_or_equal_to('balance', -amount)
# Return the latest data in the cloud upon completion.
# All the fields will be returned if the object is new,
# otherwise only fields with changes will be returned.
account.fetch_when_save = True
try:
    account.save(where=where)
    print('Balance: ', account.get('balance'))
except leancloud.LeanCloudError as e:
    if e.code == 305:
        print('Insufficient balance. Operation failed!')
    else:
        raise
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject account = AVObject.createWithoutData("Account", "5745557f71cfe40068c6abe0");
// Atomically decrease balance by 100
final int amount = -100;
account.increment("balance", amount);
// Add the condition
AVSaveOption option = new AVSaveOption();
option.query(new AVQuery<>("Account").whereGreaterThanOrEqualTo("balance", -amount));
// Return the latest data in the cloud upon completion.
// All the fields will be returned if the object is new,
// otherwise only fields with changes will be returned.
option.setFetchWhenSave(true);
account.saveInBackground(option).subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject account) {
        System.out.println("Balance: " + account.get("balance"));
    }
    public void onError(Throwable throwable) {
        System.out.println("Insufficient balance. Operation failed!");
    }
    public void onComplete() {}
});
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" %}
**`query` option only works for existing objects.** In other words, it has no effect on objects that haven't been saved to the cloud yet.

The benefit of using `query` option instead of combining `{{ baseQueryClassName }}` and `{{ baseObjectName }}` shows up when you have multiple clients trying to update the same field at the same time. The latter way is more cumbersome and may lead to potential inconsistencies.
{% endif %}

#### Updating Counters

Take Twitter as an example, we need to keep track of how many Likes and Retweets a tweet has gained so far. Since a Like or Retweet action can be triggered simultaneously by multiple clients, saving objects with updated values directly can lead to inaccurate results. To make sure that the total number is stored correctly, LeanCloud allows you to **atomically** increase (or decrease) the value of a number field:

{% if platform_name === "Objective-C" %}
```objc
[post incrementKey:@"likes" byAmount:@1];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
post.increment('likes', 1);
```
{% endif %}
{% if platform_name === "Python" %}
```python
post.increment('likes', 1)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post->increment("likes", 1);
```
{% endif %}
{% if platform_name === "Java" %}
```java
post.increment("likes", 1);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
try post.increase("likes", by: 1)
```
{% endif %}

You can specify the amount of increment (or decrement) by providing an additional argument. If the argument is not provided, `1` is used by default.

#### Updating Arrays

There are several operations that can be used to atomically update an array associated with a given key:

{% if platform_name === "Objective-C" %}
- `addObject:forKey:`<br/>appends the given object to the end of an array.
- `addObjectsFromArray:forKey:`<br/>appends the given array of objects to the end of an array.
- `addUniqueObject:forKey:`<br/>appends the given object to the end of an array ensuring that the object only appears once within the array.
- `addUniqueObjectsFromArray:forKey:`<br/>appends the given array of objects to the end of an array ensuring that each object only appears once within the array.
- `removeObject:forKey:`<br/>removes all instances of the given object from an array.
- `removeObjectsInArray:forKey:`<br/>removes all instances of the given array of objects from an array.
{% endif %}
{% if platform_name === "JavaScript" %}
- `AV.Object.add('arrayKey', value)`<br/>appends the given object to the end of an array.
- `AV.Object.addUnique('arrayKey', value)`<br/>adds the given object into an array only if it is not in it. The object will be inserted at a random position.
- `AV.Object.remove('arrayKey', value)`<br/>removes all instances of the given object from an array.
{% endif %}
{% if platform_name === "Python" %}
- `add()`<br/>appends the given object to the end of an array.
- `add_unique()`<br/>adds the given object into an array only if it is not in it. The object will be inserted at a random position.
- `remove()`<br/>removes all instances of the given object from an array.
{% endif %}
{% if platform_name === "PHP" %}
- `addIn()`<br/>appends the given object to the end of an array.
- `addUniqueIn()`<br/>adds the given object into an array only if it is not in it. The object will be inserted at a random position.
- `removeIn()`<br/>removes all instances of the given object from an array.
{% endif %}
{% if platform_name === "Java" %}
- `add()`<br/>appends the given object to the end of an array.
- `addUnique()`<br/>adds the given object into an array only if it is not in it. The object will be inserted at a random position.
- `removeAll()`<br/>removes all instances of the given object from an array.
{% endif %}
{% if platform_name === "Swift" %}
- `append(String, element: LCValue)`<br/>appends the given object to the end of an array.
- `append(String, element: LCValue, unique: Bool)`<br/>appends the given object to the end of an array. A `bool` can be specified for `unique` to ensure that the object only appears once within the array.
- `append(String, elements: [LCValue])`<br/>appends the given array of objects to the end of an array.
- `append(String, elements: [LCValue], unique: Bool)`<br/>appends the given array of objects to the end of an array. A `bool` can be specified for `unique` to ensure that each object only appears once within the array.
- `remove(String, element: LCValue)`<br/>removes all instances of the given object from an array.
- `remove(String, elements: [LCValue])`<br/>removes all instances of the given array of objects from an array.
{% endif %}

For example, `Todo` has a field named `alarms` for keeping track of times at which a user wants to be alerted. The following code adds the times to the alarms field:

{% if platform_name === "Objective-C" %}
```objc
-(NSDate*) getDateWithDateString:(NSString*) dateString{
    NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];
    [dateFormat setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSDate *date = [dateFormat dateFromString:dateString];
    return date;
}

NSDate *alarm1 = [self getDateWithDateString:@"2018-04-30 07:10:00"];
NSDate *alarm2 = [self getDateWithDateString:@"2018-04-30 07:20:00"];
NSDate *alarm3 = [self getDateWithDateString:@"2018-04-30 07:30:00"];

NSArray *alarms = [NSArray arrayWithObjects:alarm1, alarm2, alarm3, nil];

AVObject *todo = [AVObject objectWithClassName:@"Todo"];
[todo addUniqueObjectsFromArray:alarms forKey:@"alarms"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var alarm1 = new Date('2018-04-30T07:10:00');
var alarm2 = new Date('2018-04-30T07:20:00');
var alarm3 = new Date('2018-04-30T07:30:00');

var alarms = [alarm1, alarm2, alarm3];

var todo = new AV.Object('Todo');
todo.addUnique('alarms', alarms);
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

alarm1 = datetime(2018, 4, 30, 7, 10, 00)
alarm2 = datetime(2018, 4, 30, 7, 20, 00)
alarm3 = datetime(2018, 4, 30, 7, 30, 00)

Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.add_unique('alarms', alarm1)
todo.add_unique('alarms', alarm2)
todo.add_unique('alarms', alarm3)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$alarm1 = new \DateTime("2018-04-30 07:10:00");
$alarm2 = new \DateTime("2018-04-30 07:20:00");
$alarm3 = new \DateTime("2018-04-30 07:30:00");

$todo = new LeanObject("Todo");
$todo->addUniqueIn("alarms", $alarm1);
$todo->addUniqueIn("alarms", $alarm2);
$todo->addUniqueIn("alarms", $alarm3);
$todo->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date date = dateFormat.parse(dateString);
    return date;
}

Date alarm1 = getDateWithDateString("2018-04-30 07:10:00");
Date alarm2 = getDateWithDateString("2018-04-30 07:20:00");
Date alarm3 = getDateWithDateString("2018-04-30 07:30:00");

AVObject todo = new AVObject("Todo");
todo.addAllUnique("alarms", Arrays.asList(alarm1, alarm2, alarm3));
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func dateWithString(_ string: String) -> LCDate {
    let dateFormatter = DateFormatter()

    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    dateFormatter.locale = Locale(identifier: "en_US_POSIX")

    let date = LCDate(dateFormatter.date(from: string)!)

    return date
}

func testSetArray() {
    do {
        let todo = LCObject(className: "Todo")

        let reminder1 = dateWithString("2018-04-30 07:10:00")
        let reminder2 = dateWithString("2018-04-30 07:20:00")

        try todo.set("reminders", value: [reminder1, reminder2])

        let result = todo.save()
        assert(result.isSuccess)

        let reminder3 = dateWithString("2018-04-30 07:30:00")

        try todo.append("reminders", element: reminder3, unique: true)

        _ = todo.save { result in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        }
    } catch {
        print(error)
    }
}
```
{% endif %}

{# Note that it is not currently possible to atomically add and remove items from an array in the same save. You will have to call `save` in between every different kind of array operation. #}

### Deleting Objects

The following code deletes a `Todo` object from the cloud:

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo deleteInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.destroy();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->destroy();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.delete();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.delete { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "JavaScript" %}
You can delete a given field of an object with the `unset` method:

```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');

// The priority field will be removed
todo.unset('priority');

// Save the object to the cloud
todo.save();
```
{% endif %}

{# Please note that use of `object.set(null)` to remove a field from an object is not recommended and will result in unexpected functionality. #}

{% call docs.alertWrap() %}
Removing data from the cloud should always be dealt with great caution as it may lead to non-recoverable data loss. We strongly advise that you read [ACL Guide](acl-guide.html) to fully understand the risks. You should also consider implementing class-level, object-level, and field-level permissions for your classes in the cloud to guard against unauthorized data operations.
{% endcall %}

### Batch Processing

You can create, save, delete, or fetch multiple objects within a single request:

{% if platform_name === "Objective-C" %}
```objc
// Batch create and update
+ (BOOL)saveAll:(NSArray *)objects error:(NSError **)error;
+ (void)saveAllInBackground:(NSArray *)objects
                      block:(AVBooleanResultBlock)block;

// Batch delete
+ (BOOL)deleteAll:(NSArray *)objects error:(NSError **)error;
+ (void)deleteAllInBackground:(NSArray *)objects
                        block:(AVBooleanResultBlock)block;

// Batch fetch
+ (BOOL)fetchAll:(NSArray *)objects error:(NSError **)error;
+ (void)fetchAllInBackground:(NSArray *)objects
                       block:(AVArrayResultBlock)block;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Create an array for storing AV.Objects
var objects = [];

// Batch create and update
AV.Object.saveAll(objects);

// Batch delete
AV.Object.destroyAll(objects);

// Batch fetch
AV.Object.fetchAll(objects);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Batch create and update
leancloud.Object.save_all(list_of_objects)

# Batch delete
leancloud.Object.destroy_all(list_of_objects)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Batch create and update
LeanObject::saveAll()

// Batch delete
LeanObject::destroyAll()

// Batch fetch
LeanObject::fetchAll()
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Batch create and update
saveAll()
saveAllInBackground()

// Batch delete
deleteAll()
deleteAllInBackground()

// Batch fetch
fetchall()
fetchAllInBackground()
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Create an array for storing LCObjects
let objects: [LCObject] = []

// Batch create and update
_ = LCObject.save(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// Batch delete
_ = LCObject.delete(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// Batch fetch
_ = LCObject.fetch(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}

The following code sets `isComplete` of all `Todo` objects to be `true`:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query findObjectsInBackgroundWithBlock:^(NSArray *todos, NSError *error) {
    // Get a collection of todos to work on
    for (AVObject *todo in todos) {
        // Update value
        todo[@"isComplete"] = @(YES);
    }
    // Save all at once
    [AVObject saveAllInBackground:todos];
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.find().then(function (todos) {
  // Get a collection of todos to work on
  todos.forEach(function (todo) {
    // Update value
    todo.set('isComplete', true);
  });
  // Save all at once
  AV.Object.saveAll(todos);
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
# Get a collection of todos to work on
todo1 = Todo()
todo2 = Todo()
todo3 = Todo()
# Update value
todo1.set('isComplete', True)
todo2.set('isComplete', True)
todo3.set('isComplete', True)
# Save all at once
Todo.save_all([todo1, todo2, todo3])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$todos = $query->find();
// Get a collection of todos to work on
forEach ($todos as $todo) {
    // Update value
    $todo->set("isComplete", true);
}
// Save all at once
LeanObject::saveAll($todos);
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        // Get a collection of todos to work on
        for (AVObject todo : todos) {
            // Update value
            todo.put("isComplete", true);
        }
        // Save all at once
        AVObject.saveAll(todos);
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
_ = query.find { (result) in
    switch result {
    case .success(objects: let todos):
        // Get a collection of todos to work on
        for todo in todos {
            do {
                // Update value
                try todo.set("isComplete", value: true)
            } catch {
                print(error)
            }
        }
        // Save all at once
        let _ = LCObject.save(todos, completion: { (result) in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        })
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

Although each function call sends multiple operations in one single network request, saving operations and fetching operations are billed as separate API calls for each object in the collection, while deleting operations are billed as a single API call.

{% if platform_name === "Objective-C" or platform_name === "Java" or platform_name === "Swift" %}
{# ### 后台运行 #}
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "Java" %}
{# ### 离线存储对象 #}
{% endif %}

### Data Models

Objects may have relationships with other objects. For example, in a blogging application, a `Post` object may have relationships with many `Comment` objects. LeanCloud supports three kinds of relationships, including one-to-one, one-to-many, and many-to-many.

#### One-to-One and One-to-Many Relationships

One-to-one and one-to-many relationships are modeled by saving `{{ baseObjectName }}` as a value in the other object. For example, each `Comment` in a blogging app might correspond to one `Post`.

The following code creates a new `Post` with a single `Comment`:

{% if platform_name === "Objective-C" %}
```objc
// Create a post
AVObject *post = [[AVObject alloc] initWithClassName:@"Post"];
[post setObject:@"I am starving!" forKey:@"title"];
[post setObject:@"Hmmm, where should I go for lunch?" forKey:@"content"];

// Create a comment
AVObject *comment = [[AVObject alloc] initWithClassName:@"Comment"];
[comment setObject:@"KFC is the best!" forKey:@"content"];

// Add the post as a property of the comment
[comment setObject:post forKey:@"parent"];

// This will save both post and comment
[comment saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Create a post
var post = new AV.Object('Post');
post.set('title', 'I am starving!');
post.set('content', 'Hmmm, where should I go for lunch?');

// Create a comment
var comment = new AV.Object('Comment');
comment.set('content', 'KFC is the best!');

// Add the post as a property of the comment
comment.set('parent', post);

// This will save both post and comment
comment.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Create a post
Post = leancloud.Object.extend('Post')
post = Post()
post.set('title', 'I am starving!')
post.set('content', 'Hmmm, where should I go for lunch?')

# Create a comment
Comment = leancloud.Object.extend('Comment')
comment = Comment()
comment.set('content', 'KFC is the best!')

# Add the post as a property of the comment
comment.set('parent', post)

# This will save both post and comment
comment.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Create a post
$post = new LeanObject("Post");
$post->set("title", "I am starving!");
$post->set("content", "Hmmm, where should I go for lunch?");

// Create a comment
$comment = new LeanObject("Comment");
$comment->set("content", "KFC is the best!")

// Add the post as a property of the comment
$comment->set("parent", $post)

// This will save both post and comment
$comment->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Create a post
AVObject post = new AVObject("Post");
post.put("title", "I am starving!");
post.put("content", "Hmmm, where should I go for lunch?");

// Create a comment
AVObject comment = new AVObject("Comment");
comment.put("content", "KFC is the best!");

// Add the post as a property of the comment
comment.put("parent", post);

// This will save both post and comment
comment.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // Create a post
    let post = LCObject(className: "Post")
    try post.set("title", value: "I am starving!")
    try post.set("content", value: "Hmmm, where should I go for lunch?")

    // Create a comment
    let comment = LCObject(className: "Comment")
    try comment.set("content", value: "KFC is the best!")

    // Add the post as a property of the comment
    try comment.set("parent", value: post)

    // This will save both post and comment
    assert(comment.save().isSuccess)
} catch {
    print(error)
}
```
{% endif %}

Internally, the backend will store the referred-to object with the `Pointer` type in just one place in order to maintain consistency. You can also link objects using their `objectId`s like this:

{% if platform_name === "Objective-C" %}
```objc
AVObject *post = [AVObject objectWithClassName:@"Post" objectId:@"57328ca079bc44005c2472d0"];
[comment setObject:post forKey:@"post"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
comment.set('post', post);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
comment.set('post', post)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$comment->set("post", $post)
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject post = AVObject.createWithoutData("Post", "57328ca079bc44005c2472d0");
comment.put("post", post);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
try comment.set("post", value: post)
```
{% endif %}

See [Relational Queries](#relational-queries) for instructions on how to query relational data.

#### Many-to-Many Relationships

The easiest way to model many-to-many relationships is to use **arrays**. In most cases, using arrays helps you reduce the number of queries you need to make and leads to a better performance. However, if additional properties need to be attached to the relationships between two classes, using **join tables** would be a better choice. Keep in mind that the additional properties are used to describe the relationships between classes rather than any single class.

We recommend you to use join tables if the total amount of objects of any class exceeds 100.

{% call docs.noteWrap() %}
Modeling relationships among data could be a tough work. We have written a dedicated article to address [Data Modeling](relation-guide.html) in greater detail, which we highly recommend you reading.
{% endcall %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" or platform_name === "Swift" %}
{# ### 序列化和反序列化 #}
{% endif %}

{% if platform_name === "Python" %}
{# ### 线程安全 #}
{% endif %}

## Queries

We've already seen how you can retrieve a single object from the cloud with `{{ baseObjectName }}`, but it doesn't seem to be powerful enough when you need to retrieve multiple objects that match certain conditions at once. In such situation, `{{ baseQueryClassName }}` would be a more efficient tool you can use.

{# Before you continue, familiarize yourself with the models that are used in this guide. #}

### Basic Queries

The general steps of performing a basic query include:

1. Creating `{{ baseQueryClassName }}`.
2. Putting conditions on it.
3. Retrieving an array of objects matching the conditions.

The code below retrieves all `Student` objects whose `lastName` is `Smith`:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Student"];
[query whereKey:@"lastName" equalTo:@"Smith"];
[query findObjectsInBackgroundWithBlock:^(NSArray *students, NSError *error) {
    // students is an array of Student objects satisfying conditions
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Student');
query.equalTo('lastName', 'Smith');
query.find().then(function (students) {
  // students is an array of Student objects satisfying conditions
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Student = leancloud.Object.extend('Student')
query = Student.query
query.equal_to('lastName', 'Smith')
student_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Student");
$query->equalTo("lastName", "Smith");
$students = $query->find();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Student");
query.whereEqualTo("lastName", "Smith");
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> students) {
        // students is an array of Student objects satisfying conditions
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Student")
query.whereKey("lastName", .equalTo("Smith"))
_ = query.find { result in
    switch result {
    case .success(objects: let students):
        // students is an array of Student objects satisfying conditions
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

### Query Constraints

There are several ways to put constraints on the objects found by `{{ baseObjectName }}`.

The code below filters out objects with `Jack` as `firstName`:

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"firstName" notEqualTo:@"Jack"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.notEqualTo('firstName', 'Jack');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.not_equal_to("firstName", 'Jack')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->notEqualTo("firstName", "Jack");
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.whereNotEqualTo("firstName", "Jack");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .notEqualTo("Jack"))
```
{% endif %}

For sortable types like numbers and strings, you can use comparisons in queries:

{% if platform_name === "Objective-C" %}
```objc
// Restricts to age < 18
[query whereKey:@"age" lessThan:@18];

// Restricts to age <= 18
[query whereKey:@"age" lessThanOrEqualTo:@18];

// Restricts to age > 18
[query whereKey:@"age" greaterThan:@18];

// Restricts to age >= 18
[query whereKey:@"age" greaterThanOrEqualTo:@18];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Restricts to age < 18
query.lessThan('age', 18);

// Restricts to age <= 18
query.lessThanOrEqualTo('age', 18);

// Restricts to age > 18
query.greaterThan('age', 18);

// Restricts to age >= 18
query.greaterThanOrEqualTo('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Restricts to age < 18
query.less_than('age', 18)

# Restricts to age <= 18
query.less_than_or_equal_to('age', 18)

# Restricts to age > 18
query.greater_than('age', 18)

# Restricts to age >= 18
query.greater_than_or_equal_to('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Restricts to age < 18
$query->lessThan("age", 18);

// Restricts to age <= 18
$query->lessThanOrEqualTo("age", 18);

// Restricts to age > 18
$query->greaterThan("age", 18);

// Restricts to age >= 18
$query->greaterThanOrEqualTo("age", 18);
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Restricts to age < 18
query.whereLessThan("age", 18);

// Restricts to age <= 18
query.whereLessThanOrEqualTo("age", 18);

// Restricts to age > 18
query.whereGreaterThan("age", 18);

// Restricts to age >= 18
query.whereGreaterThanOrEqualTo("age", 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Restricts to age < 18
query.whereKey("age", .lessThan(18));

// Restricts to age <= 18
query.whereKey("age", .lessThanOrEqualTo(18));

// Restricts to age > 18
query.whereKey("age", .greaterThan(18));

// Restricts to age >= 18
query.whereKey("age", .greaterThanOrEqualTo(18));
```
{% endif %}

You can apply multiple constraints to a single query, and objects will only be in the results if they match all of the constraints. In other words, it's like concatenating constraints with `AND`:

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"firstName" equalTo:@"Jack"];
[query whereKey:@"age" greaterThan:@18];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.equalTo('firstName', 'Jack');
query.greaterThan('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to("firstName", 'Jack')
query.greater_than('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("firstName", "Jack");
$query->greaterThan("age", 18);
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.whereEqualTo("firstName", "Jack");
query.whereGreaterThan("age", 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .equalTo("Jack"))
query.whereKey("age", .greaterThan(18))
```
{% endif %}

You can limit the number of results by setting `limit` (defaults to `100`):

{% if platform_name === "Objective-C" %}
```objc
// Limit to at most 10 results
query.limit = 10;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Limit to at most 10 results
query.limit(10);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Limit to at most 10 results
query.limit(10)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Limit to at most 10 results
$query->limit(10);
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Limit to at most 10 results
query.limit(10);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Limit to at most 10 results
query.limit = 10
```
{% endif %}

{% call docs.noteWrap() %}
For performance reasons, the maximum value allowed for `limit` is `1000`, meaning that LeanCloud would only return 1,000 results even it is set to be greater than `1000`.
{% endcall %}

If you need exactly one result, you may use `{% if platform_name === "Objective-C" %}getFirstObject{% endif %}{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Java" %}getFirst{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}` for convenience:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"priority" equalTo:@2];
[query getFirstObjectInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    // todo is the first Todo object satisfying conditions
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.first().then(function (todo) {
  // todo is the first Todo object satisfying conditions
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
todo = query.first()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$todo = $query->first();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("priority", 2);
query.getFirstInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todo) {
        // todo is the first Todo object satisfying conditions
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        print(todo)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

You can skip certain number of results by setting `skip`:

{% if platform_name === "Objective-C" %}
```objc
// Skip the first 20 results
query.skip = 20;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Skip the first 20 results
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Skip the first 20 results
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Skip the first 20 results
$query->skip(20);
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Skip the first 20 results
query.skip(20);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Skip the first 20 results
query.skip = 20
```
{% endif %}

You can implement pagination in your app by using `skip` together with `limit`:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"priority" equalTo:@2];
query.limit = 10;
query.skip = 20;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.limit(10);
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
query.limit(10)
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$query->limit(10);
$query->skip(20);
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("priority", 2);
query.limit(10);
query.skip(20);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
query.limit = 10
query.skip = 20
```
{% endif %}

{% call docs.noteWrap() %}
Keep in mind that the higher the `skip` goes, the slower the query will run. You may consider using `createdAt` or `updatedAt` (which are indexed) to set range boundaries for large datasets to make queries more efficient. {# , or using the last value returned from an auto-increment field along with `limit` for the purpose of pagination #}
{% endcall %}

For sortable types, you can control the order in which results are returned:

{% if platform_name === "Objective-C" %}
```objc
// Sorts the results in ascending order by the createdAt property
[query orderByAscending:@"createdAt"];

// Sorts the results in descending order by the createdAt property
[query orderByDescending:@"createdAt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Sorts the results in ascending order by the createdAt property
query.ascending('createdAt');

// Sorts the results in descending order by the createdAt property
query.descending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Sorts the results in ascending order by the createdAt property
query.ascending('createdAt')

# Sorts the results in descending order by the createdAt property
query.descending('createdAt')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Sorts the results in ascending order by the createdAt property
$query->ascend("createdAt");

// Sorts the results in descending order by the createdAt property
$query->descend("createdAt");
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Sorts the results in ascending order by the createdAt property
query.orderByAscending("createdAt");

// Sorts the results in descending order by the createdAt property
query.orderByDescending("createdAt");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Sorts the results in ascending order by the createdAt property
query.whereKey("createdAt", .ascending)

// Sorts the results in descending order by the createdAt property
query.whereKey("createdAt", .descending)
```
{% endif %}

You can even attach multiple sorting rules to a single query:

{% if platform_name === "Objective-C" %}
```objc
[query addAscendingOrder:@"priority"];
[query addDescendingOrder:@"createdAt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.addAscending('priority');
query.addDescending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.add_ascending('createdAt')
query.add_descending('priority')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->addAscend("priority");
$query->addDescend("createdAt");
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.addAscendingOrder("priority");
query.addDescendingOrder("createdAt");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .ascending)
query.whereKey("createdAt", .descending)
```
{% endif %}

To retrieve objects that have or do not have particular fields:

{% if platform_name === "Objective-C" %}
```objc
// Finds objects that have the "images" field
[query whereKeyExists:@"images"];

// Finds objects that don't have the "images" field
[query whereKeyDoesNotExist:@"images"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Finds objects that have the 'images' field
query.exists('images');

// Finds objects that don't have the 'images' field
query.doesNotExist('images');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Finds objects that have the 'images' field
query.exists('images')

# Finds objects that don't have the 'images' field
query.does_not_exist('images')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Finds objects that have the "images" field
$query->exists("images");

// Finds objects that don't have the "images" field
$query->notExists("images");
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Finds objects that have the "images" field
query.whereExists("images");

// Finds objects that don't have the "images" field
query.whereDoesNotExist("images");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Finds objects that have the "images" field
query.whereKey("images", .existed)

// Finds objects that don't have the "images" field
query.whereKey("images", .notExisted)
```
{% endif %}

{% if platform_name === "JavaScript" %}
You can use the `matchesKeyInQuery` method to look for objects with values of fields matching those of objects returned by another query.

For example, if you have a `Country` class matching countries with languages and a `Student` class matching students with their nationalities:

name | language
--- | ---
US | English
UK | English
China | Chinese

fullName | nationality
--- | ---
John Doe | US
Tom Sawyer | UK
Ming Li | China

The following code looks for all the students who are from English-speaking countries:

```js
var studentQuery = new AV.Query('Student');
var countryQuery = new AV.Query('Country');
// Get all English-speaking countries
countryQuery.equalTo('language', 'English');
// Match Student's nationality with Country's name
studentQuery.matchesKeyInQuery('nationality', 'name', countryQuery);
studentQuery.find().then(function (students) {
  // students contains John Doe and Tom Sawyer
});
```
{% endif %}

You can restrict the fields returned by providing a list of keys with `{% if platform_name === "Objective-C" %}selectKeys{% endif %}{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Java" %}selectKeys{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}`. The code below retrieves todos with only the `title` and `content` fields (and also special built-in fields such as `objectId`, `createdAt`, and `updatedAt`):

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query selectKeys:@[@"title", @"content"]];
[query getFirstObjectInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    NSString *title = todo[@"title"]; // √
    NSString *content = todo[@"content"]; // √
    NSString *notes = todo[@"notes"]; // An error will occur
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.select(['title', 'content']);
query.first().then(function (todo) {
  var title = todo.get('title'); // √
  var content = todo.get('content'); // √
  var notes = todo.get('notes'); // undefined
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.select('title', 'content')
todo = query.first()

title = todo.get('title') # √
content = todo.get('content') # √
notes = todo.get('notes') # None
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->select("title", "content");
$todo = $query->first();

$title = $todo->get("title"); // √
$content = $todo->get("content"); // √
$notes = $todo->get("notes"); // null
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.selectKeys(Arrays.asList("title", "content"));
query.getFirstInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todo) {
        String title = todo.getString("title"); // √
        String content = todo.getString("content"); // √
        String notes = todo.getString("notes"); // An error will occur
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("title", .selected)
query.whereKey("content", .selected)
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        let title = todo.get("title") // √
        let content = todo.get("content") // √
        let notes = todo.get("notes") // nil
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" or platform_name === "Swift" %}
The unselected fields can be fetched later with `{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Java" %}fetchInBackground{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}`. See [Refreshing Objects](#refreshing-objects).
{% endif %}

### Queries on String Values

Use `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}` to restrict to string values that start with a particular string. Similar to a `LIKE` operator in SQL, it is indexed so it is efficient for large datasets:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// SQL equivalent: title LIKE 'lunch%'
[query whereKey:@"title" hasPrefix:@"lunch"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
// SQL equivalent: title LIKE 'lunch%'
query.startsWith('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# SQL equivalent: title LIKE 'lunch%'
query.startswith("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// SQL equivalent: title LIKE 'lunch%'
$query->startsWith("title", "lunch");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
// SQL equivalent: title LIKE 'lunch%'
query.whereStartsWith("title", "lunch");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// SQL equivalent: title LIKE 'lunch%'
query.whereKey("title", .prefixedBy("lunch"))
```
{% endif %}

Use `{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` to restrict to string values that contain a particular string:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// SQL equivalent: title LIKE '%lunch%'
[query whereKey:@"title" containsString:@"lunch"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
// SQL equivalent: title LIKE '%lunch%'
query.contains('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# SQL equivalent: title LIKE '%lunch%'
query.contains("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// SQL equivalent: title LIKE '%lunch%'
$query->contains("title", "lunch");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
// SQL equivalent: title LIKE '%lunch%'
query.whereContains("title", "lunch");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// SQL equivalent: title LIKE '%lunch%'
query.whereKey("title", .matchedSubstring("lunch"))
```
{% endif %}

Unlike `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}`, `{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` can't take advantage of indexes, which is not encouraged to be used for large datasets.

{% call docs.noteWrap() %}
Please note that both `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}` and `{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` perform **case-sensitive** matching, so the examples above will not look for string values containing `Lunch`, `LUNCH`, etc.
{% endcall %}

If you are looking for string values that do not contain a particular string, use `{% if platform_name === "Objective-C" %}matchesRegex{% endif %}{% if platform_name === "JavaScript" %}matches{% endif %}{% if platform_name === "Python" %}matched{% endif %}{% if platform_name === "PHP" %}matches{% endif %}{% if platform_name === "Java" %}whereMatches{% endif %}{% if platform_name === "Swift" %}.matchedPattern{% endif %}` with regular expressions:

{% if platform_name === "Objective-C" %}
<pre><code class="lang-objc">AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// "title" without "ticket" (case-insensitive)
[query whereKey:@"title" matchesRegex:@"{{ regex() | safe }}];    
</code></pre>
{% endif %}
{% if platform_name === "JavaScript" %}
<pre><code class="lang-js">var query = new AV.Query('Todo');
// 'title' without 'ticket' (case-insensitive)
var regExp = new RegExp('{{ regex(true) | safe }}, 'i');
query.matches('title', regExp);
</code></pre>
{% endif %}
{% if platform_name === "Python" %}
<pre><code class="lang-python">Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 'title' without 'ticket' (case-insensitive)
query.matched('title', '{{ regex(true) | safe }})
</code></pre>
{% endif %}
{% if platform_name === "PHP" %}
<pre><code class="lang-php">$query = new Query("Todo");
// "title" without "ticket" (case-insensitive)
$query->matches("title","{{ regex() | safe }});
</code></pre>
{% endif %}
{% if platform_name === "Java" %}
<pre><code class="lang-java">AVQuery<AVObject> query = new AVQuery<>("Todo");
// "title" without "ticket" (case-insensitive)
query.whereMatches("title","{{ regex() | safe }});
</code></pre>
{% endif %}
{% if platform_name === "Swift" %}
<pre><code class="lang-swift">let query = LCQuery(className: "Todo")
// "title" without "ticket" (case-insensitive)
query.whereKey("title", .matchedPattern("{{ regex() | safe }}, option: nil))
</code></pre>
{% endif %}

{# 2016-12-29 DO NOT USE markdown to rewrite the previous block #}

However, performing queries with regular expressions as constraints can be very expensive, especially for classes with over 100,000 records. {# LeanCloud restricts how many such operations can be run on a particular app at any given time. #} The reason behind is that queries like this can't take advantage of indexes and will lead to exhaustive scanning of the whole dataset to find the matching objects. We recommend that you take a look at our [In-App Searching](#in-app-searching) feature, a full-text search solution we provide to improve your app's searching ability and user experience.

{% call docs.noteWrap() %}
If you are facing performance issues with queries, please refer to [Optimizing Performance](#optimizing-performance) for possible workarounds and best practices.
{% endcall %}

### Queries on Array Values

The code below looks for all the objects with `work` as an element of its array field `tags`:

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"tags" equalTo:@"work"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.equalTo('tags', 'work');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to('tags', 'work')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("tags", "work");
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.whereEqualTo("tags", "work");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .equalTo("work"))
```
{% endif %}

You can also look for objects whose array field `tags` contains `work`, `sales`, **and** `appointment`:

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"tags" containsAllObjectsInArray:[NSArray arrayWithObjects:@"work", @"sales", @"appointment", nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.containsAll('tags', ['work', 'sales', 'appointment']);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.contains_all('tags', ['work', 'sales', 'appointment'])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->containsAll("tags", array("work", "sales", "appointment"));
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.whereContainsAll("tags", Arrays.asList("work", "sales", "appointment"));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .containedAllIn(["work", "sales", "appointment"]))
```
{% endif %}

To retrieve objects whose field matches any one of the values in a given list, you can use `{% if platform_name === "Objective-C" %}containedIn{% endif %}{% if platform_name === "JavaScript" %}containedIn{% endif %}{% if platform_name === "Python" %}contained_in{% endif %}{% if platform_name === "PHP" %}containedIn{% endif %}{% if platform_name === "Java" %}whereContainedIn{% endif %}{% if platform_name === "Swift" %}.containedIn{% endif %}` instead of performing multiple queries. The code below constructs a query that retrieves todo items with `priority` to be `1` **or** `2`:

{% if platform_name === "Objective-C" %}
```objc
// Single query
AVQuery *priorityOneOrTwo = [AVQuery queryWithClassName:@"Todo"];
[priorityOneOrTwo whereKey:@"priority" containedIn:[NSArray arrayWithObjects:@1, @2, nil]];
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
AVQuery *priorityOne = [AVQuery queryWithClassName:@"Todo"];
[priorityOne whereKey:@"priority" equalTo:@1];

AVQuery *priorityTwo = [AVQuery queryWithClassName:@"Todo"];
[priorityTwo whereKey:@"priority" equalTo:@2];

AVQuery *priorityOneOrTwo = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:priorityOne, priorityTwo, nil]];
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Single query
var priorityOneOrTwo = new AV.Query('Todo');
priorityOneOrTwo.containedIn('priority', [1, 2]);
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
var priorityOne = new AV.Query('Todo');
priorityOne.equalTo('priority', 1);

var priorityTwo = new AV.Query('Todo');
priorityTwo.equalTo('priority', 2);

var priorityOneOrTwo = AV.Query.or(priorityOne, priorityTwo);
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Single query
Todo = leancloud.Object.extend('Todo')
priority_one_or_two = Todo.query
priority_one_or_two.contained_in('priority', [1, 2])
# Mission completed :)

# ---------------
#       vs.
# ---------------

# Multiple queries
Todo = leancloud.Object.extend('Todo')

priority_one = Todo.query
priority_one.equal_to('priority', 1)

priority_two = Todo.query
priority_two.equal_to('priority', 2)

priority_one_or_two = leancloud.Query.or_(priority_one, priority_two)
# Kind of verbose :(
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Single query
$priorityOneOrTwo = new Query("Todo");
$priorityOneOrTwo->containedIn("priority", array(1, 2));
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
$priorityOne = new Query("Todo");
$priorityOne->equalTo("priority", 1);

$priorityTwo = new Query("Todo");
$priorityTwo->equalTo("priority", 2);

$query = Query::orQuery($priorityOne, $priorityTwo);
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Single query
AVQuery<AVObject> priorityOneOrTwo = new AVQuery<>("Todo");
priorityOneOrTwo.whereContainedIn("priority", Arrays.asList(1, 2));
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
final AVQuery<AVObject> priorityOne = new AVQuery<>("Todo");
priorityOne.whereEqualTo("priority", 1);

final AVQuery<AVObject> priorityTwo = new AVQuery<>("Todo");
priorityTwo.whereEqualTo("priority", 2);

AVQuery<AVObject> priorityOneOrTwo = AVQuery.or(Arrays.asList(priorityOne, priorityTwo));
// Kind of verbose :(
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Single query
let priorityOneOrTwo = LCQuery(className: "Todo")
priorityOneOrTwo.whereKey("priority", .containedIn([1, 2]))
// Mission completed :)

// ---------------
//       vs.
// ---------------

// Multiple queries
let priorityOne = LCQuery(className: "Todo")
priorityOne.whereKey("priority", .equalTo(1))

let priorityTwo = LCQuery(className: "Todo")
priorityTwo.whereKey("priority", .equalTo(2))

let priorityOneOrTwo = priorityOne.or(priorityTwo)
// Kind of verbose :(
```
{% endif %}

Conversely, you can use `{% if platform_name === "Objective-C" %}notContainedIn{% endif %}{% if platform_name === "JavaScript" %}notContainedIn{% endif %}{% if platform_name === "Python" %}not_contained_in{% endif %}{% if platform_name === "PHP" %}notContainedIn{% endif %}{% if platform_name === "Java" %}whereNotContainedIn{% endif %}{% if platform_name === "Swift" %}.notContainedIn{% endif %}` if you want to retrieve objects that do not match any of the values in a list.

### Relational Queries

There are several ways to perform queries for relational data. To retrieve objects whose given field matches a particular `{{ baseObjectName }}`, you can use `{% if platform_name === "Objective-C" %}equalTo{% endif %}{% if platform_name === "JavaScript" %}equalTo{% endif %}{% if platform_name === "Python" %}equal_to{% endif %}{% if platform_name === "PHP" %}equalTo{% endif %}{% if platform_name === "Java" %}whereEqualTo{% endif %}{% if platform_name === "Swift" %}.equalTo{% endif %}` just like how you use it for other data types. For example, if each `Comment` has a `Post` object in its `post` field, you can fetch all the comments for a particular `Post` with the following code:

{% if platform_name === "Objective-C" %}
```objc
AVObject *post = [AVObject objectWithClassName:@"Post" objectId:@"57328ca079bc44005c2472d0"];
AVQuery *query = [AVQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" equalTo:post];
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments contains the comments for the post
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
var query = new AV.Query('Comment');
query.equalTo('post', post);
query.find().then(function (comments) {
  // comments contains the comments for the post
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
query = leancloud.Query('Comment')
query.equal_to('post', post)
comment_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$query = new Query("Comment");
$query->equalTo("post", $post);
$comments = $query->find();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject post = AVObject.createWithoutData("Post", "57328ca079bc44005c2472d0");
AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereEqualTo("post", post);
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> comments) {
        // comments contains the comments for the post
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
let query = LCQuery(className: "Comment")
query.whereKey("post", .equalTo(post))
_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments contains the comments for the post
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

To retrieve objects whose given field contains `{{ baseObjectName }}` that matches a different query, you can use `{% if platform_name === "Objective-C" %}matchesQuery{% endif %}{% if platform_name === "JavaScript" %}matchesQuery{% endif %}{% if platform_name === "Python" %}matches_query{% endif %}{% if platform_name === "PHP" %}matchesInQuery{% endif %}{% if platform_name === "Java" %}whereMatchesQuery{% endif %}{% if platform_name === "Swift" %}.matchedQuery{% endif %}`. The code below constructs a query that looks for all the comments for posts with images:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *innerQuery = [AVQuery queryWithClassName:@"Post"];
[innerQuery whereKeyExists:@"images"];

AVQuery *query = [AVQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" matchesQuery:innerQuery];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var innerQuery = new AV.Query('Post');
innerQuery.exists('image');

var query = new AV.Query('Comment');
query.matchesQuery('post', innerQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
inner_query = leancloud.Query('Post')
inner_query.exists('images')

query = leancloud.Query('Comment')
query.matches_query('post', inner_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$innerQuery = new Query("Post");
$innerQuery->exists("images");

$query = new Query("Comment");
$query->matchesInQuery("post", $innerQuery);
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> innerQuery = new AVQuery<>("Post");
innerQuery.whereExists("image");

AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereMatchesQuery("post", innerQuery);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let innerQuery = LCQuery(className: "Post")
innerQuery.whereKey("image", .existed)

let query = LCQuery(className: "Comment")
query.whereKey("post", .matchedQuery(innerQuery))
```
{% endif %}

To retrieve objects whose given field does not contain `{{ baseObjectName }}` that matches a different query, use `{% if platform_name === "Objective-C" %}doesNotMatchQuery{% endif %}{% if platform_name === "JavaScript" %}doesNotMatchQuery{% endif %}{% if platform_name === "Python" %}does_not_match_query{% endif %}{% if platform_name === "PHP" %}notMatchInQuery{% endif %}{% if platform_name === "Java" %}whereDoesNotMatchQuery{% endif %}{% if platform_name === "Swift" %}.notMatchedQuery{% endif %}` instead.

Sometimes you may need to look for related objects from different classes without extra queries. In such situations, you can use `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` on the same query. The following code retrieves the last 10 comments together with the posts related to them:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Comment"];

// Retrieve the most recent ones
[query orderByDescending:@"createdAt"];

// Only retrieve the last 10
query.limit = 10;

// Include the related post together with each comment
[query includeKey:@"post"];

[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments contains the last 10 comments including the post associated with each
    for (AVObject *comment in comments) {
        // This does not require a network access
        AVObject *post = comment[@"post"];
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Comment');

// Retrieve the most recent ones
query.descending('createdAt');

// Only retrieve the last 10
query.limit(10);

// Include the related post together with each comment
query.include('post');

query.find().then(function (comments) {
  // comments contains the last 10 comments including the post associated with each
  comments.forEach(function (comment) {
    // This does not require a network access
    var post = comment.get('post');
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Comment')

# Retrieve the most recent ones
query.add_descending('createdAt')

# Only retrieve the last 10
query.limit(10)

# Include the related post together with each comment
query.include('post')

comment_list = query.find()
for comment in comment_list:
    # This does not require a network access
    post = comment.get('post')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Comment");

// Retrieve the most recent ones
$query->descend("createdAt");

// Only retrieve the last 10
$query->limit(10);

// Include the related post together with each comment
$query->_include("post");

$comments = $query->find();
forEach($comments as $comment) {
    // This does not require a network access
    $post = $comment->get("post");
}
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Comment");

// Retrieve the most recent ones
query.orderByDescending("createdAt");

// Only retrieve the last 10
query.limit(10);

// Include the related post together with each comment
query.include("post");

query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> comments) {
        // comments contains the last 10 comments including the post associated with each
        for (AVObject comment : comments) {
            // This does not require a network access
            AVObject post = comment.getAVObject("post");
        }
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Comment")

// Retrieve the most recent ones
query.whereKey("createdAt", .descending)

// Only retrieve the last 10
query.limit = 10

// Include the related post together with each comment
query.whereKey("post", .included)

_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments contains the last 10 comments including the post associated with each
        for comment in comments {
            // This does not require a network access
            let post = comment.get("post") as? LCObject
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

You can even indicate multi-level associations using dot notations. If you wanted to include the post for each comment as well as the author of the post, you can do:

{% if platform_name === "Objective-C" %}
```objc
[query includeKey:@"post.author"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.include('post.author');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.include('post.author')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->_include("post.author");
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.include("post.author");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author", .included)
```
{% endif %}

Feel free to use `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` as many times as you need for the same query to have multiple fields included. Related objects retrieved in this way also works with `{{ baseQueryClassName }}` helpers like `{% if platform_name === "Objective-C" %}getFirstObject{% endif %}{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Java" %}getFirst{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}`{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Swift" %} and `get`{% endif %}.

{% call docs.noteWrap() %}
Multi-level conditions passed into `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` won't work with any `{{ baseObjectName }}` contained in an array field. The furthest level that can be reached is the field itself.
{% endcall %}

You can also use dot notations with `{% if platform_name === "Objective-C" %}selectKeys{% endif %}{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Java" %}selectKeys{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}` to limit the fields returned from the related objects:

{% if platform_name === "Objective-C" %}
```objc
[query selectKeys:@[@"post.author.firstName"]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.select('post.author.firstName');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.select('post.author.firstName')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->select("post.author.firstName");
```
{% endif %}
{% if platform_name === "Java" %}
```java
query.selectKeys(Arrays.asList("post.author.firstName"));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author.firstName", .selected)
```
{% endif %}

#### Caveats about Relational Queries

The backend of LeanCloud is not built on relational databases, which makes it impossible to join tables while querying. For the relational queries mentioned above, what LeanCloud would do is to first perform an inner query (with `100` as default `limit` and `1000` as maximum) and then insert the result from this query into the outer query. If the number of records matching the inner query exceeds the `limit` and the outer query contains other constraints, the amount of the records returned in the end could be zero or less than your expectation since only the records within the `limit` would be inserted into the outer query.

The following actions can be taken to solve the problem:

- Make sure the number of records in the result of the inner query is no more than 100. If it is between 100 and 1,000, set `1000` as the `limit` of the inner query.
- Create redundancy for the fields being queried by the inner query on the table for the outer query.
- Repeat the same query with different `skip` values until all the records are gone through (performance issue could occur if the value of `skip` gets too big).

### Counting Objects

If you just need to count how many objects match a query but do not need to retrieve the actual objects, use `{% if platform_name === "Objective-C" %}countObjectsInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}count{% endif %}{% if platform_name === "Python" %}count{% endif %}{% if platform_name === "PHP" %}count{% endif %}{% if platform_name === "Java" %}count{% endif %}{% if platform_name === "Swift" %}count{% endif %}` instead of `{% if platform_name === "Objective-C" %}findObjectsInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}find{% endif %}{% if platform_name === "Python" %}find{% endif %}{% if platform_name === "PHP" %}find{% endif %}{% if platform_name === "Java" %}findInBackground{% endif %}{% if platform_name === "Swift" %}find{% endif %}`. For example, to count how many todos have been completed:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"isComplete" equalTo:@(YES)];
[query countObjectsInBackgroundWithBlock:^(NSInteger count, NSError *error) {
    NSLog(@"%ld todos completed.", count);
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('isComplete', true);
query.count().then(function (count) {
  console.log(count + " todos completed.");
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('isComplete', True)
count = query.count()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("isComplete", true);
$count = $query->count();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("isComplete", true);
query.countInBackground().subscribe(new Observer<Integer>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(Integer count) {
        System.out.println(count + " todos completed.");
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("isComplete", .equalTo(true))
let count = query.count()
```
{% endif %}

### Compound Queries

Compound queries can be used if complex query conditions need to be specified. A compound query is a logical combination (`OR` or `AND`) of subqueries.

{% call docs.noteWrap() %}
Note that we do not support `GeoPoint` or non-filtering constraints (e.g. `near`, `withinGeoBox`, `limit`, `skip`, `ascending`, `descending`, `include`) in the subqueries of a compound query.
{% endcall %}

#### OR-ed Query Constraints

An object will be returned as long as it fulfills any one of the subqueries. The code below constructs a query that looks for all the todos that either have priorities higher than or equal to `3`, or are already completed:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *priorityQuery = [AVQuery queryWithClassName:@"Todo"];
[priorityQuery whereKey:@"priority" greaterThanOrEqualTo:@3];

AVQuery *isCompleteQuery = [AVQuery queryWithClassName:@"Todo"];
[isCompleteQuery whereKey:@"isComplete" equalTo:@(YES)];

AVQuery *query = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:priorityQuery, isCompleteQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var priorityQuery = new AV.Query('Todo');
priorityQuery.greaterThanOrEqualTo('priority', 3);

var isCompleteQuery = new AV.Query('Todo');
isCompleteQuery.equalTo('isComplete', true);

var query = AV.Query.or(priorityQuery, isCompleteQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')

priority_query = Todo.query
priority_query.greater_than_or_equal_to('priority', 3)

is_complete_query = Todo.query
is_complete_query.equal_to('isComplete', True)

query = leancloud.Query.or_(priority_query, is_complete_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$priorityQuery = new Query("Todo");
$priorityQuery->greaterThanOrEqualTo("priority", 3);

$isCompleteQuery = new Query("Todo");
$isCompleteQuery->equalTo("isComplete", true);

$query = Query::orQuery($priorityQuery, $isCompleteQuery);
```
{% endif %}
{% if platform_name === "Java" %}
```java
final AVQuery<AVObject> priorityQuery = new AVQuery<>("Todo");
priorityQuery.whereGreaterThanOrEqualTo("priority", 3);

final AVQuery<AVObject> isCompleteQuery = new AVQuery<>("Todo");
isCompleteQuery.whereEqualTo("isComplete", true);

AVQuery<AVObject> query = AVQuery.or(Arrays.asList(priorityQuery, isCompleteQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let priorityQuery = LCQuery(className: "Todo")
priorityQuery.whereKey("priority", .greaterThanOrEqualTo(3))

let isCompleteQuery = LCQuery(className: "Todo")
isCompleteQuery.whereKey("isComplete", .equalTo(true))

let query = priorityQuery.or(isCompleteQuery)
```
{% endif %}

{% call docs.noteWrap() %}
Queries regarding `GeoPoint` cannot be present among OR-ed queries.
{% endcall %}

#### AND-ed Query Constraints

The effect of using AND-ed query is the same as adding constraints to `{{ baseQueryClassName }}`. The code below constructs a query that looks for all the todos that are created between `2016-11-13` and `2016-12-02`:

{% if platform_name === "Objective-C" %}
```objc
NSDate *(^dateFromString)(NSString *string) = ^(NSString *string) {
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    return [dateFormatter dateFromString:string];
};

AVQuery *startDateQuery = [AVQuery queryWithClassName:@"Todo"];
[startDateQuery whereKey:@"createdAt" greaterThanOrEqualTo:dateFromString(@"2016-11-13")];

AVQuery *endDateQuery = [AVQuery queryWithClassName:@"Todo"];
[endDateQuery whereKey:@"createdAt" lessThan:dateFromString(@"2016-12-03")];

AVQuery *query = [AVQuery andQueryWithSubqueries:[NSArray arrayWithObjects:startDateQuery, endDateQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var startDateQuery = new AV.Query('Todo');
startDateQuery.greaterThanOrEqualTo('createdAt', new Date('2016-11-13 00:00:00'));

var endDateQuery = new AV.Query('Todo');
endDateQuery.lessThan('createdAt', new Date('2016-12-03 00:00:00'));

var query = AV.Query.and(startDateQuery, endDateQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

start_date_query = Todo.query
start_date_query.greater_than_or_equal_to('createdAt', datetime(2016, 11, 13))

end_date_query = Todo.query
end_date_query.less_than('createdAt', datetime(2016, 12, 3))

query = leancloud.Query.and_(start_date_query, end_date_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2016-11-13");
$startDateQuery = new Query("Todo");
$startDateQuery->greaterThanOrEqualTo("createdAt", $startDate);

$endDate = new \DateTime("2016-12-03");
$endDateQuery = new Query("Todo");
$endDateQuery->lessThan("createdAt", $endDate);

$query = Query::andQuery($startDateQuery, $endDateQuery);
```
{% endif %}
{% if platform_name === "Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

final AVQuery<AVObject> startDateQuery = new AVQuery<>("Todo");
startDateQuery.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2016-11-13"));

final AVQuery<AVObject> endDateQuery = new AVQuery<>("Todo");
endDateQuery.whereLessThan("createdAt", getDateWithDateString("2016-12-03"));

AVQuery<AVObject> query = AVQuery.and(Arrays.asList(startDateQuery, endDateQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let startDateQuery = LCQuery(className: "Todo")
startDateQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2016-11-13")))

let endDateQuery = LCQuery(className: "Todo")
endDateQuery.whereKey("createdAt", .lessThan(dateFromString("2016-12-03")))

let query = startDateQuery.and(endDateQuery)
```
{% endif %}

While using an AND-ed query by itself doesn't bring anything new comparing to a basic query, combining AND-ed queries with OR-ed queries together allows you to implement complicated query conditions in your program. The code below constructs a query that looks for all the todos created today that either have no `location` set or have `3` as `priority`:

{% if platform_name === "Objective-C" %}
```objc
NSDate *(^dateFromString)(NSString *string) = ^(NSString *string) {
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    return [dateFormatter dateFromString:string];
};

AVQuery *createdAtQuery = [AVQuery queryWithClassName:@"Todo"];
[createdAtQuery whereKey:@"createdAt" greaterThanOrEqualTo:dateFromString(@"2018-04-30")];
[createdAtQuery whereKey:@"createdAt" lessThan:dateFromString(@"2018-05-01")];

AVQuery *locationQuery = [AVQuery queryWithClassName:@"Todo"];
[locationQuery whereKeyDoesNotExist:@"location"];

AVQuery *priorityQuery = [AVQuery queryWithClassName:@"Todo"];
[priorityQuery whereKey:@"priority" equalTo:@3];

AVQuery *orQuery = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:locationQuery, priorityQuery, nil]];
AVQuery *query = [AVQuery andQueryWithSubqueries:[NSArray arrayWithObjects:createdAtQuery, orQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var createdAtQuery = new AV.Query('Todo');
createdAtQuery.greaterThanOrEqualTo('createdAt', new Date('2018-04-30'));
createdAtQuery.lessThan('createdAt', new Date('2018-05-01'));

var locationQuery = new AV.Query('Todo');
locationQuery.doesNotExist('location');

var priorityQuery = new AV.Query('Todo');
priorityQuery.equalTo('priority', 3);

var orQuery = AV.Query.or(locationQuery, priorityQuery);
var query = AV.Query.and(createdAtQuery, orQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

created_at_query = Todo.query
created_at_query.greater_than_or_equal_to('createdAt', datetime(2018, 4, 30))
created_at_query.less_than('createdAt', datetime(2018, 5, 1))

location_query = Todo.query
location_query.does_not_exist('location')

priority_query = Todo.query
priority_query.equal_to('priority', 3)

or_query = leancloud.Query.or_(location_query, priority_query)
query = leancloud.Query.and_(created_at_query, or_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2018-04-30");
$endDate = new \DateTime("2018-05-01");
$createdAtQuery = new Query("Todo");
$createdAtQuery->greaterThanOrEqualTo("createdAt", $startDate);
$createdAtQuery->lessThan("createdAt", $endDate);

$locationQuery = new Query("Todo");
$locationQuery->notExists("location");

$priorityQuery = new Query("Todo");
$priorityQuery->equalTo("priority", 3);

$orQuery = Query::orQuery($locationQuery, $priorityQuery)
$query = Query::andQuery($createdAtQuery, $orQuery);
```
{% endif %}
{% if platform_name === "Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

final AVQuery<AVObject> createdAtQuery = new AVQuery<>("Todo");
createdAtQuery.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2018-04-30"));
createdAtQuery.whereLessThan("createdAt", getDateWithDateString("2018-05-01"));

final AVQuery<AVObject> locationQuery = new AVQuery<>("Todo");
locationQuery.whereDoesNotExist("location");

final AVQuery<AVObject> priorityQuery = new AVQuery<>("Todo");
priorityQuery.whereEqualTo("priority", 3);

AVQuery<AVObject> orQuery = AVQuery.or(Arrays.asList(locationQuery, priorityQuery));
AVQuery<AVObject> query = AVQuery.and(Arrays.asList(createdAtQuery, orQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let createdAtQuery = LCQuery(className: "Todo")
createdAtQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2018-04-30")))
createdAtQuery.whereKey("createdAt", .lessThan(dateFromString("2018-05-01")))

let locationQuery = LCQuery(className: "Todo")
locationQuery.whereKey("location", .notExisted)

let priorityQuery = LCQuery(className: "Todo")
priorityQuery.whereKey("priority", .equalTo(3))

let orQuery = locationQuery.or(priorityQuery)
let query = createdAtQuery.and(orQuery)
```
{% endif %}

{% if platform_name === "Objective-C" %}
{# ### 缓存查询 #}
{% endif %}

### Optimizing Performance

There are several factors that could lead to potential performance issues when you conduct a query, especially when more than 100,000 records are returned at a time. We are listing some common ones here so you can design your apps accordingly to avoid them:

- Querying with "not equal to" or "not include" (index will not work)
- Querying on strings with a wildcard at the beginning of the pattern (index will not work)
- Using `count` with conditions (all the entries will be gone through)
- Using `skip` for a great number of entries (all the entries that need to be skipped will be gone through)
- Sorting without index (querying and sorting cannot share a composite index unless the conditions used on them are both covered by the same one)
- Querying without index (the conditions used on the query cannot share a composite index unless all of them are covered by the same one; additional time will be consumed if excessive data falls under the uncovered conditions)

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" %}
## LiveQuery

LiveQuery is, as its name implies, derived from [`{{ baseQueryClassName }}`](#queries) but has enhanced capability. It allows you to automatically synchronize data changes from one client to other clients without writing complex code, making it suitable for apps that need real-time data.

Suppose you are building an app that allows multiple users to edit the same file at the same time. `{{ baseQueryClassName }}` would not be an ideal tool since it is based on a pull model and you cannot know when to query from the cloud to get the updates.

To solve this problem, we introduced LiveQuery. This tool allows you to subscribe to the `{{ baseQueryClassName }}`s you are interested in. Once subscribed, the cloud will notify clients by generating event messages whenever `{{ baseObjectName }}`s that match the `{{ baseQueryClassName }}` are created or updated, in real-time.

Behind the scene, we use WebSocket connections to have clients and the cloud communicate with each other and maintain the subscription status of clients. In most cases, it isn't necessary to deal with the WebSocket connections directly, so we developed a simple API to help you focus on your business logic rather than technical implementations.

### Initializing LiveQuery

To use LiveQuery in your app, go to your app's [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf) and check the **Enable LiveQuery** option under the **Other** section{% if platform_name === "Objective-C" %}, then add the following pod into the `Podfile` under the project's root directory:{% endif %}{% if platform_name === "JavaScript" %}, then include the following npm module in your project:{% endif %}{% if platform_name === "Java" %}. Make sure the RTM modules are added into `AndroidManifest.xml`:{% endif %}

{% if platform_name === "Objective-C" %}
```ruby
pod 'AVOSCloudLiveQuery'
```

See [Installing SDK](#installing-sdk) for more details.
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// No need to require leancloud-storage if the following line is present
var AV = require('leancloud-storage/live-query');
```

Or load it with the following `<script>` tag:

```html
<!-- No need to load av-min.js if the following script is present -->
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

See [Installing SDK](#installing-sdk) for more details.
{% endif %}
{% if platform_name === "Java" %}
```xml
<service android:name="cn.leancloud.push.PushService"/>
<receiver android:name="cn.leancloud.push.AVBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED"/>
    <action android:name="android.intent.action.USER_PRESENT"/>
    <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
  </intent-filter>
</receiver>
```

See [Initializing Your Project](#initializing-your-project) for more details.
{% endif %}

{# ### Demo #}

### Creating a Subscription

To make a query **live**, create a normal `{{ baseQueryClassName }}` object, put conditions on it if there are, and then subscribe to it:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
self.liveQuery = [[AVLiveQuery alloc] initWithQuery:query];
self.liveQuery.delegate = self;
[self.liveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    // Query becomes live after getting a subscription
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.subscribe().then(function (liveQuery) {
  // Query becomes live after getting a subscription
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // Query becomes live after getting a subscription
        }
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
You can't use subqueries or restrict fields being returned when using LiveQuery.
{% endcall %}

Now you will be able to receive updates related to `{{ baseObjectName }}`. If an `Todo` object is created by another client with `Update Portfolio` as `title`, the following code can get the new `Todo` for you:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
self.liveQuery = [[AVLiveQuery alloc] initWithQuery:query];
self.liveQuery.delegate = self;
[self.liveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    // Query becomes live after getting a subscription
}];
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"%@", object[@"title"]); // Update Portfolio
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.subscribe().then(function (liveQuery) {
  liveQuery.on('create', function (newTodo) {
    console.log(newTodo.get('title')); // Update Portfolio
  });
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectCreated(AVObject newTodo) {
        System.out.println(newTodo.getString("title")); // Update Portfolio
    }
});
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // Query becomes live after getting a subscription
        }
    }
});
```
{% endif %}

If someone updates this `Todo` by changing its `content` to `Add my recent paintings`, the following code can get the updated version for you:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidUpdate:(id)updatedTodo updatedKeys:(NSArray<NSString *> *)updatedKeys {
    NSLog(@"%@", updatedTodo[@"content"]); // Add my recent paintings
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (updatedTodo, updatedKeys) {
  console.log(updatedTodo.get('content')); // Add my recent paintings
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectUpdated(AVObject updatedTodo, List<String> updatedKeys) {
        System.out.println(updatedTodo.getString("content")); // Add my recent paintings
    }
});
```
{% endif %}

### Event Handling

The following types of data changes can be monitored once subscription is set up:

- `create`
- `update`
- `enter`
- `leave`
- `delete`
- `login`

#### `create` Event

A `create` event will be triggered when a new `{{ baseObjectName }}` is created and it fulfills the `{{ baseQueryClassName }}` you subscribed. The `object` is the new `{{ baseObjectName }}` being created:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"Object created.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('create', function (object) {
  console.log('Object created.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectCreated(AVObject object) {
        System.out.println("Object created.");
    }
});
```
{% endif %}

#### `update` Event

An `update` event will be triggered when an existing `{{ baseObjectName }}` fulfilling the `{{ baseQueryClassName }}` you subscribed is updated. The `object` is the `{{ baseObjectName }}` being updated:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidUpdate:(id)object updatedKeys:(NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"Object updated.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (object, updatedKeys) {
  console.log('Object updated.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectUpdated(AVObject object, List<String> updatedKeys) {
        System.out.println("Object updated.");
    }
});
```
{% endif %}

#### `enter` Event

An `enter` event will be triggered when an existing `{{ baseObjectName }}`'s old value does not fulfill the `{{ baseQueryClassName }}` you subscribed but its new value does. The `object` is the `{{ baseObjectName }}` entering the `{{ baseQueryClassName }}` and its content is the latest value of it:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidEnter:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"Object entered.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('enter', function (object, updatedKeys) {
  console.log('Object entered.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectEnter(AVObject object, List<String> updatedKeys) {
        System.out.println("Object entered.");
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
There is a clear distinction between a `create` event and an `enter` event. If an object already exists and later matches the query's conditions, an `enter` event will be triggered. If an object didn't exist already and is later created, a `create` event will be triggered.
{% endcall %}

#### `leave` Event

A `leave` event will be triggered when an existing `{{ baseObjectName }}`'s old value fulfills the `{{ baseQueryClassName }}` you subscribed but its new value does not. The `object` is the `{{ baseObjectName }}` leaving the `{{ baseQueryClassName }}` and its content is the latest value of it:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidLeave:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"Object left.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('leave', function (object, updatedKeys) {
  console.log('Object left.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectLeave(AVObject object, List<String> updatedKeys) {
        System.out.println("Object left.");
    }
});
```
{% endif %}

#### `delete` Event

A `delete` event will be triggered when an existing `{{ baseObjectName }}` fulfilling the `{{ baseQueryClassName }}` you subscribed is deleted. The `object` is the `objectId` of the `{{ baseObjectName }}` being deleted:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidDelete:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"Object deleted.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('delete', function (object) {
  console.log('Object deleted.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectDeleted(String object) {
        System.out.println("Object deleted.");
    }
});
```
{% endif %}

#### `login` Event

A `login` event will be triggered when a user successfully logs in to your app. The `user` is the `{{ userObjectName }}` logged in:

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery userDidLogin:(AVUser *)user {
    if (liveQuery == self.liveQuery) {
        NSLog(@"User logged in.");
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('login', function (user) {
  console.log('User logged in.');
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onUserLogin(AVUser user) {
        System.out.println("User logged in.");
    }
});
```
{% endif %}

### Unsubscribing

You can cancel a subscription to stop receiving events regarding `{{ baseQueryClassName }}`. After that, you won't get any events from the subscription.

{% if platform_name === "Objective-C" %}
```objc
[liveQuery unsubscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    if (succeeded) {
        // Successfully unsubscribed
    } else {
        // Error handling
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.unsubscribe().then(function () {
  // Successfully unsubscribed
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
liveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // Successfully unsubscribed
        }
    }
});
```
{% endif %}

### Losing Connections

There are different scenarios regarding losing connections:

1. The connection to the Internet is lost unexpectedly.
2. The user performs certain operations outside of the app, like switching the app to the background, turning off the phone, or turning on the flight mode.

For the scenarios above, you don't need to do any extra work. As long as the user switches back to the app, the SDK will automatically re-establish the connection.

There is another scenario when **the user completely kills the app or closes the web page**. In this case, the SDK cannot automatically re-establish the connection. You will have to create subscriptions again by yourself.

### Caveats about LiveQuery

Given the real-time feature of LiveQuery, developers may find it tempting to use it for instant messaging. As LiveQuery is neither designed nor optimized for completing such tasks, we discourage such use of this tool, let alone there will be additional cost for saving message history and rising challenges of code maintenance. We recommend using [our real-time messaging solution](realtime_v2.html) for this scenario.
{% endif %}

## Files

`{{ fileObjectName }}` allows you to store application files in the cloud that would otherwise be too large or cumbersome to fit into a regular `{{ baseObjectName }}`. The most common use case is storing images, but you can also use it for documents, videos, music, and any other binary data.

### Creating Files

{% if platform_name === "Objective-C" %}
You can create a file from a string:

```objc
NSData *data = [@"LeanCloud" dataUsingEncoding:NSUTF8StringEncoding];
// resume.txt is the file name
AVFile *file = [AVFile fileWithData:data name:@"resume.txt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
You can create a file from a base64-encoded string:

```js
var data = { base64: 'TGVhbkNsb3Vk' };
// resume.txt is the file name
var file = new AV.File('resume.txt', data);
```

You can also create a file from an array of byte values:

```js
var data = [0x4c, 0x65, 0x61, 0x6e, 0x43, 0x6c, 0x6f, 0x75, 0x64];
var file = new AV.File('resume.txt', data);
```
{% endif %}
{% if platform_name === "Python" %}
You can create a file from a string:

```python
from StringIO import StringIO

data = StringIO('LeanCloud')
# resume.txt is the file name
file = leancloud.File('resume.txt', data)
```

You can also create a file from byte values with `buffer`:

```python
data = buffer('\x4c\x65\x61\x6e\x43\x6c\x6f\x75\x64')
file = leancloud.File('resume.txt', data)
```
{% endif %}
{% if platform_name === "PHP" %}
You can create a file from a string:

```php
// resume.txt is the file name
$file = File::createWithData("resume.txt", "LeanCloud");
```
{% endif %}
{% if platform_name === "Java" %}
You can create a file from a string:

```java
// resume.txt is the file name
AVFile file = new AVFile("resume.txt", "LeanCloud".getBytes());
```
{% endif %}
{% if platform_name === "Swift" %}
You can create a file from a string:

```swift
if let data = "LeanCloud".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
}
```
{% endif %}

You can also create a file from a URL:

{% if platform_name === "Objective-C" %}
```objc
AVFile *file = [AVFile fileWithRemoteURL:[NSURL URLWithString:@"https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png"]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var file = AV.File.withURL(
  'logo.png',
  'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png'
);
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_with_url('logo.png', 'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithUrl("logo.png", "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVFile file = new AVFile(
    "logo.png",
    "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png",
    new HashMap<String, Object>()
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = URL(string: "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png") {
    let file = LCFile(url: url)
}
```
{% endif %}

{% call docs.noteWrap() %}
When creating files from URLs, the SDK will not upload the actual files into the cloud but will store the addresses of the files as strings. This will not lead to actual traffic for uploading files, as opposed to creating files in other ways by doing which the files will be actually stored into the cloud.
{% endcall %}

{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Java" or platform_name === "Swift" %}
LeanCloud will auto-detect the type of the file you are uploading based on the file extension, but you can also specify the `Content-Type` (commonly referred to as MIME type):
{% endif %}

{% if platform_name === "JavaScript" %}
```js
var file = new AV.File('resume.txt', data, 'application/json');
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File('resume.txt', StringIO('{"company":"LeanCloud"}'), 'application/json')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithData("resume.txt", "{\"company\":\"LeanCloud\"}", "application/json");
```
{% endif %}
{% if platform_name === "Java" %}
```java
Map<String, Object> meta = new HashMap<String, Object>();
meta.put("mime_type", "application/json");
AVFile file = new AVFile("resume.txt", "LeanCloud".getBytes(), meta);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let data = "{\"company\":\"LeanCloud\"}".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
    file.mimeType = "application/json"
}
```
{% endif %}

But the most common method for creating files is to upload them from local paths{{ ". In a web app, you can first create an input button in the user interface:" if platform_name === "JavaScript" else ":" }}

{% if platform_name === "Objective-C" %}
```objc
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
NSString *imagePath = [documentsDirectory stringByAppendingPathComponent:@"avatar.jpg"];
NSError *error;
AVFile *file = [AVFile fileWithLocalPath:imagePath error:&error];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```html
<input type="file" id="avatar-upload" />
```

Then get a reference to that file in a click handler:

```js
var avatarUpload = document.getElementById('avatar-upload');
if (avatarUpload.files.length) {
  var localFile = avatarUpload.files[0];
  var file = new AV.File('avatar.jpg', localFile);
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
with open('/tmp/avatar.jpg', 'rb') as f:
    file = leancloud.File('avatar.jpg', f)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithLocalFile("/tmp/avatar.jpg");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVFile file = AVFile.withAbsoluteLocalPath("avatar.jpg", "/tmp/avatar.jpg");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = Bundle.main.url(forResource: "avatar", withExtension: "jpg") {
    let file = LCFile(payload: .fileURL(fileURL: url))
}
```
{% endif %}

The file we uploaded here is named `avatar.jpg`. There are a couple of things to note here:

- Each file uploaded will get its unique `objectId`, so it is allowed for multiple files to share the same name.
- A correct extension needs to be assigned to each file which the cloud will use to infer the type of a file. For example, if you are storing a PNG image with `{{ fileObjectName }}`, use `.png` as its extension.
- If the file doesn't have an extension and the content type is not specified, LeanCloud defaults the file's type to be `application/octet-stream`.

### Saving Files

By saving a file, you store it into the cloud and get a permanent URL pointing to it:

{% if platform_name === "Objective-C" %}
```objc
[file uploadWithCompletionHandler:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        NSLog(@"File uploaded. objectId: %@", file.objectId);
    } else {
        // The file either could not be read or could not be saved to LeanCloud
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
file.save().then(function (file) {
  console.log('File uploaded. objectId: ' + file.id);
}, function (error) {
  // The file either could not be read or could not be saved to LeanCloud
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
file.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
file.saveInBackground().subscribe(new Observer<AVFile>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVFile file) {
        System.out.println("File uploaded. objectId: " + file.getObjectId());
    }
    public void onError(Throwable throwable) {
        // The file either could not be read or could not be saved to LeanCloud
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = file.save { result in
    switch result {
    case .success:
        if let value = file.objectId?.value {
            print("File uploaded. objectId: " + value)
        }
    case .failure(error: let error):
        // The file either could not be read or could not be saved to LeanCloud
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
A file successfully uploaded can be found in the `_File` class and cannot be modified later. If you need to change the file, you have to upload the modified file again and a new `objectId` and URL will be generated.
{% endcall %}

You can associate a file with `{{ baseObjectName }}` after it is saved:

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo"];
[todo setObject:@"Get Cakes" forKey:@"title"];
// attachments is an Array field
[todo addObject:file forKey:@"attachments"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var Todo = AV.Object.extend('Todo');
var todo = new Todo();
todo.set('title', 'Get Cakes');
// attachments is an Array field
todo.add('attachments', file);
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.set('title', 'Get Cakes')
# attachments is an Array field
todo.add('attachments', file)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");
$todo->set("title", "Get Cakes");
// attachments is an Array field
$todo->addIn("attachments", $file);
$todo->save();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject todo = new AVObject("Todo");
todo.put("title", "Get Cakes");
// attachments is an Array field
todo.add("attachments", file);
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
todo.set("title", value: "Get Cakes")
do {
    if let _ = file.objectId?.value {
        let todo = LCObject(className: "Todo")
        try todo.set("attachments", value: file)
        todo.save { (result) in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" %}
On a related note, if the files are referenced in an array field of `{{ baseObjectName }}` and you want to get them within the same query for `{{ baseObjectName }}`, you need to use the `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Java"%}include{% endif %}` method with `{{ baseQueryClassName }}`. For example, if you are retrieving all the todos with the same title `Get Cakes` and you want to retrieve their related attachments at the same time:
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
// Get all todos with the same title and contain attachments
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"title" equalTo:@"Get Cakes"];
[query whereKeyExists:@"attachments"];

// Include attachments with each todo
[query includeKey:@"attachments"];

[query findObjectsInBackgroundWithBlock:^(NSArray * _Nullable todos, NSError * _Nullable error) {
    for (AVObject *todo in todos) {
        // Get attachments array for each todo
        // {# TODO #}
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Get all todos with the same title and contain attachments
var query = new AV.Query('Todo');
query.equalTo('title', 'Get Cakes');
query.exists('attachments');

// Include attachments with each todo
query.include('attachments');

query.find().then(function (todos) {
  todos.forEach(function (todo) {
    // Get attachments array for each todo
    var attachments = todo.get('attachments');
    attachments.forEach(function (attachment) {
      // Each attachment is an AV.File instance
      console.log('URL of the attachment: ', attachment.get('url'));
    });
  });
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Get all todos with the same title and contain attachments
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("title", "Get Cakes");
query.whereExists("attachments");

// Include attachments with each todo
query.include("attachments");

query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        for (AVObject todo : todos) {
            // Get attachments array for each todo
            // {# TODO #}
        }
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" or platform_name === "Swift" %}
### Upload Progress

You can monitor the progress of uploading and display that to the user:
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
[file uploadWithProgress:^(NSInteger percent) {
    // percent is an integer between 0 and 100, indicating uploading progress
} completionHandler:^(BOOL succeeded, NSError *error) {
    // Things to do after saving
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
file.save({
  onprogress: function (progress) {
    console.log(progress);
    // {
    //   loaded:  1024,
    //   total:   2048,
    //   percent: 50
    // }
  }
}).then(function (file) {
  // Things to do after saving
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
Observable<AVFile> result = file.saveInBackground(new ProgressCallback() {
    @Override
    public void done(Integer percent) {
        // percent is an integer between 0 and 100, indicating uploading progress
    }
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = file.save(progress: { (progress) in
    print(progress)
}) { (result) in
    switch result {
    case .success:
        // Things to do after saving
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

### File Metadata

When uploading a file, you can attach additional properties to it with `metaData`. A file's `metaData` cannot be updated once the file is stored to the cloud.

{% if platform_name === "Objective-C" %}
```objc
// Set metadata
[file.metaData setObject:@"LeanCloud" forKey:@"author"];
[file uploadWithCompletionHandler:^(BOOL succeeded, NSError *error) {
    // Get all metadata
    NSDictionary *metadata = file.metaData;
    // Get author
    NSString *author = metadata[@"author"];
    // Get file name
    NSString *fileName = file.name;
    // Get size (not available for files created from base64-encoded strings or URLs)
    NSUInteger *size = file.size;
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Set metadata
file.metaData('author', 'LeanCloud');
file.save().then(function (file) {
  // Get all metadata
  var metadata = file.metaData();
  // Get author
  var author = file.metaData('author');
  // Get file name
  var fileName = file.get('name');
  // Get size (not available for files created from base64-encoded strings or URLs)
  var size = file.size();
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Set metadata
file.metadata['author'] = 'LeanCloud'
file.save()

# Get all metadata
metadata = file.metadata
# Get author
author = metadata['author']
# Get file name
file_name = file.name
# Get size (not available for files created from base64-encoded strings or URLs)
size = file.size
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Set metadata
$file->setMeta("author", "LeanCloud");
$file->save();

// Get all metadata
$metadata = $file->getMeta();
// Get author
$author = $file->getMeta("author");
// Get file name
$fileName = $file->getName();
// Get size (not available for files created from base64-encoded strings or URLs)
$size = $file->getSize();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Set metadata
file.addMetaData("author", "LeanCloud");
file.saveInBackground().subscribe(new Observer<AVFile>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVFile file) {
        // Get author
        String author = (String) file.getMetaData("author");
        // Get file name
        String fileName = file.getName();
        // Get size (not available for files created from base64-encoded strings or URLs)
        int size = file.getSize();
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// Set metadata
file.metaData["author"] = "LeanCloud"
_ = file.save { result in
    switch result {
    case .success:
        // Get author
        String? author = file.metaData["author"]
        // Get file name
        String? fileName = file.name
        // Get size (not available for files created from base64-encoded strings or URLs)
        UInt64? size = file.metaData["size"]
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" %}
{# ### 文件下载 #}
{% endif %}

{% if platform_name === "Objective-C" %}
{# ### 清除缓存 #}
{% endif %}

### Deleting Files

The code below deletes a file from the cloud:

{% if platform_name === "Objective-C" %}
```objc
AVFile *file = [AVFile getFileWithObjectId:@"552e0a27e4b0643b709e891e"];
[file deleteInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var file = AV.File.createWithoutData('552e0a27e4b0643b709e891e');
file.destroy();
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_without_data('552e0a27e4b0643b709e891e')
file.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::fetch("552e0a27e4b0643b709e891e");
$file->destroy();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject file = AVObject.createWithoutData("_File", "552e0a27e4b0643b709e891e");
file.delete()
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let file = LCObject(className: "_File", objectId: "552e0a27e4b0643b709e891e")
file.delete()
```
{% endif %}

{% call docs.alertWrap() %}
By default, a file is not allowed to be deleted. You can change the setting by going to [Dashboard > LeanStorage > Data > `_File`](https://console.leancloud.app/data.html?appid={{appid}}#/_File) and select **Others** > **Permission settings** > **`delete`**.
{% endcall %}

{% if platform_name === "Objective-C" %}
#### HTTP Support for iOS 9 and Up

Starting iOS 9, Apple requires HTTPS connections for iOS apps and denies HTTP connections by default. All LeanCloud APIs support HTTPS except for the `getData` method of `AVFile`.

If your app still needs to make HTTP requests, such as when accessing files in LeanMessage that still reference to insecure domains, you should add those insecure domains to your project's `Info.plist`:

Right-click on `Info.plist`, choose **Opened As** > **Source Code**, append the following text to the node **plist** > **dict**:

```xml
<key>NSAppTransportSecurity</key>
<dict>
  <key>NSExceptionDomains</key>
  <dict>
    <key>amazonaws.com</key>
    <dict>
      <key>NSIncludesSubdomains</key>
      <true/>
      <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
      <true/>
    </dict>
  </dict>
</dict>
```

{# Or go to your project's **Target** panel, open the **Info** tab and modify settings there as illustrated below:

![](../images/ios_qiniu_http.png) #}

You may also allow all HTTP traffics if you need. See [iOS9AdaptationTips](https://github.com/ChenYilong/iOS9AdaptationTips) for more information.
{% endif %}

### CDN Support

You can set up your own CDN to improve the speed your users access the files stored on LeanCloud. Take [Amazon CloudFront CDN](https://aws.amazon.com/cloudfront/) as an example:

1. Read [Getting Started with CloudFront](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html).
2. Create an Amazon AWS account, and choose a CloudFront subscription plan that suits your business.
3. LeanCloud has got S3's read permission properly configured, so you can skip [Step 2: Upload your content to Amazon S3 and grant object permissions](http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html#GettingStartedUploadContent) in the guide and proceed with other steps.
4. Take the domain name from the URL of your `{{ fileObjectName }}` and fill it into CloudFront's **Origin Domain Name**. Leave the other settings with defaults.

{% if platform_name === "JavaScript" %}
## Promises

Each asynchronous method in LeanCloud JavaScript SDK returns a `Promise` which can be used to handle the completion and exception of the method. The example below updates an `AV.Object` after it is being queried:

```js
let query = new AV.Query('Todo');
query.equalTo('priority', 1);
// find is asynchronous which gives back a Promise that then can be called on
query.find().then(function (todos) {
  // Returns a list of objects
  let todo = todos[0];
  todo.set('notes', 'Needs to be finished today.');
  // save is also asynchronous which gives back a Promise that you can return here and chain another Promise afterwards
  return todo.save();
}).then(function () {
  // The Promise returned by save method
  console.log('Successfully updated todo.');
}).catch(function (error) {
  // Put catch at the very end of Promise chain which catches all the errors
  console.error(error);
});
```

### The `then` Method

Each `Promise` has a method called `then` which takes in two callbacks. The first callback is called when the `Promise` is `resolved` (runs successfully) while the second one is called when it is `rejected` (gets error):

```js
todo.save().then(function (todo) {
  console.log('Successfully updated todo.');
}, function (error) {
  console.error(error);
});
```

The second callback is optional.

You may also implement your logic with `catch`:

```js
todo.save().then(function (todo) {
  console.log('Successfully updated todo.');
}).catch(function (error) {
  console.error(error);
});
```

### Chaining Promises Together

Promise allows you to elegantly connect asynchronous requests together according to the order they should be called. If the callback of a `Promise` returns another `Promise`, the callback in the second `then` will not be resolved unless the one in the first `then` is resolved. This is also called **Promise Chain**.

```js
// Add contents to the page following the order of chapters
let chapterIds = [
  '584e1c408e450a006c676162', // Chapter One
  '584e1c43128fe10058b01cf5', // Chapter Two
  '581aff915bbb500059ca8d0b'  // Chapter Three
];

new AV.Query('Chapter').get(chapterIds[0]).then(function (chapterOne) {
  // Add contents to the page
  addHtmlToPage(chapterOne.get('content'));
  // Return the new Promise
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapterTwo) {
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapterThree) {
  addHtmlToPage(chapterThree.get('content'));
  // Done
});
```

### Error Handling with Promises

If any single `Promise` in the chain throws an error, all the callbacks following it meant for successful operations will be skipped until an error handling callback is encountered.

It is a common practice to attach an error handling function at the end of a `Promise` chain.

The code above can be rewritten with `catch` in the following way:

```js
new AV.Query('Chapter').get(chapterIds[0]).then(function (chapterOne) {
  addHtmlToPage(chapterOne.get('content'));
  // Force an error
  throw new Error('Error');
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapterTwo) {
  // The code here will be ignored
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapterThree) {
  // The code here will be ignored
  addHtmlToPage(chapterThree.get('content'));
}).catch(function (error) {
  // This error handling function will be called, printing out the error message 'Error'
  console.error(error.message);
});
```

### `async` and `await`

`async` and `await` allows you to use Promise by writing code in a more synchronous manner:

```js
async function example() {
  try {
    let query = new AV.Query('Todo');
    query.equalTo('priority', 1);
    let todos = await query.find();
    let todo = todos[0];
    todo.set('notes', 'Needs to be finished today.');
    return await todo.save();
  } catch (error) {
    console.error(error);
  }
}
```

Further reading on Promises:

- [Promises/A+ Proposal](https://github.com/promises-aplus/promises-spec)
{% endif %}

## GeoPoints

LeanCloud allows you to associate real-world latitude and longitude coordinates with an object by adding `{{ geoPointObjectName }}` to the `{{ baseObjectName }}`. By doing so, queries on the proximity of an object to a given point can be performed, allowing you to easily implement functions like looking for users or places nearby.

To associate a point with an object, you need to create the point first. The code below creates `{{geoPointObjectName}}` with `39.9` as `latitude` and `116.4` as `longitude`:

{% if platform_name === "Objective-C" %}
```objc
AVGeoPoint *point = [AVGeoPoint geoPointWithLatitude:39.9 longitude:116.4];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var point = new AV.GeoPoint(39.9, 116.4);

// Other ways of creating the same AV.GeoPoint
var point = new AV.GeoPoint([39.9, 116.4]);
var point = new AV.GeoPoint({ latitude: 39.9, longitude: 116.4 });
```
{% endif %}
{% if platform_name === "Python" %}
```python
point = leancloud.GeoPoint(39.9, 116.4)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$point = new GeoPoint(39.9, 116.4);
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
```
{% endif %}

Now you can store the point in an object as a regular field:

{% if platform_name === "Objective-C" %}
```objc
[todo setObject:point forKey:@"location"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
todo.set('location', point);
```
{% endif %}
{% if platform_name === "Python" %}
```python
todo.set('location', point)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo->set("location", $point);
```
{% endif %}
{% if platform_name === "Java" %}
```java
todo.put("location", point);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
try todo.set("location", value: point)
```
{% endif %}

### Geo Queries

With a number of existing objects with spatial coordinates, you can find out which of them are closest to a given point, or are contained within a particular area. This can be done by adding another restriction to `{{ baseQueryClassName }}` using `{% if platform_name === "Objective-C" %}nearGeoPoint{% endif %}{% if platform_name === "JavaScript" %}near{% endif %}{% if platform_name === "Python" %}near{% endif %}{% if platform_name === "PHP" %}near{% endif %}{% if platform_name === "Java" %}whereNear{% endif %}{% if platform_name === "Swift" %}.locatedNear{% endif %}`. The code below returns a list of `Todo` objects with `location` closest to a given point:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
AVGeoPoint *point = [AVGeoPoint geoPointWithLatitude:39.9 longitude:116.4];
[query whereKey:@"location" nearGeoPoint:point];

// Limit to 10 results
query.limit = 10;
[query findObjectsInBackgroundWithBlock:^(NSArray *todos, NSError *error) {
    // todos is an array of Todo objects satisfying conditions
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var point = new AV.GeoPoint(39.9, 116.4);
query.near('location', point);

// Limit to 10 results
query.limit(10);
query.find().then(function (todos) {
  // todos is an array of Todo objects satisfying conditions
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
point = leancloud.GeoPoint(39.9, 116.4)
query.near('location', point)

# Limit to 10 results
query.limit(10)
todo_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$point = new GeoPoint(39.9, 116.4);
$query->near("location", $point);

// Limit to 10 results
$query->limit(10);
$todos = $query->find();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
query.whereNear("location", point);

// Limit to 10 results
query.limit(10);
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        // todos is an array of Todo objects satisfying conditions
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
query.whereKey("location", .locatedNear(point))

// Limit to 10 results
query.limit = 10
_ = query.find { result in
    switch result {
    case .success(objects: let todos):
        // todos is an array of Todo objects satisfying conditions
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
Additional sorting conditions like `{% if platform_name === "Objective-C" %}orderByAscending{% endif %}{% if platform_name === "JavaScript" %}ascending{% endif %}{% if platform_name === "Python" %}ascending{% endif %}{% if platform_name === "PHP" %}ascend{% endif %}{% if platform_name === "Java" %}orderByAscending{% endif %}{% if platform_name === "Swift" %}.ascending{% endif %}` and `{% if platform_name === "Objective-C" %}orderByDescending{% endif %}{% if platform_name === "JavaScript" %}descending{% endif %}{% if platform_name === "Python" %}descending{% endif %}{% if platform_name === "PHP" %}descend{% endif %}{% if platform_name === "Java" %}orderByDescending{% endif %}{% if platform_name === "Swift" %}.descending{% endif %}` will gain higher priorities than the default order by distance.
{% endcall %}

To have the results limited within a certain distance, check out {% if platform_name === "Objective-C" %}`withinKilometers`, `withinMiles`, and `withinRadians`{% endif %}{% if platform_name === "JavaScript" %}`withinKilometers`, `withinMiles`, and `withinRadians`{% endif %}{% if platform_name === "Python" %}`within_kilometers`, `within_miles`, and `within_radians`{% endif %}{% if platform_name === "PHP" %}`withinKilometers`, `withinMiles`, and `withinRadians`{% endif %}{% if platform_name === "Java" %}`whereWithinKilometers`, `whereWithinMiles`, and `whereWithinRadians`{% endif %}{% if platform_name === "Swift" %}`.locatedNear`'s `from` and `to` parameters{% endif %} in our API docs.

You can also query for the set of objects that are contained within a rectangular bounding box with {% if platform_name === "Objective-C" %}`withinGeoBoxFromSouthwest` and `toNortheast`{% endif %}{% if platform_name === "JavaScript" %}`withinGeoBox`{% endif %}{% if platform_name === "Python" %}`within_geo_box`{% endif %}{% if platform_name === "PHP" %}`withinBox`{% endif %}{% if platform_name === "Java" %}`whereWithinGeoBox`{% endif %}{% if platform_name === "Swift" %}`.locatedWithin`{% endif %}:

<img width="300" height="200" src="images/geopoint-withingeobox.svg" />

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
AVGeoPoint *southwest = [AVGeoPoint geoPointWithLatitude:30 longitude:115];
AVGeoPoint *northeast = [AVGeoPoint geoPointWithLatitude:40 longitude:118];
[query whereKey:@"location" withinGeoBoxFromSouthwest:southwest toNortheast:northeast];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var southwest = new AV.GeoPoint(30, 115);
var northeast = new AV.GeoPoint(40, 118);
query.withinGeoBox('location', southwest, northeast);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
southwest = leancloud.GeoPoint(30, 115)
northeast = leancloud.GeoPoint(40, 118)
query.within_geo_box('location', southwest, northeast)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$southwest = new GeoPoint(30, 115);
$northeast = new GeoPoint(40, 118);
$query->withinBox("location", $southwest, $northeast);
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVGeoPoint southwest = new AVGeoPoint(30, 115);
AVGeoPoint northeast = new AVGeoPoint(40, 118);
query.whereWithinGeoBox("location", southwest, northeast);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let southwest = LCGeoPoint(latitude: 30, longitude: 115)
let northeast = LCGeoPoint(latitude: 40, longitude: 118)
query.whereKey("location", .locatedWithin(southwest: southwest, northeast: northeast))
```
{% endif %}

### Caveats about GeoPoints

There are a couple of things to keep in mind:

- Each `{{ baseObjectName }}` may only have one field containing `{{ geoPointObjectName }}` object.
- Points should not exceed the extreme ends of the ranges. Latitude should be between `-90.0` and `90.0`. Longitude should be between `-180.0` and `180.0`. Attempting to set latitude or longitude out of bounds will cause an error.
{# - Using the `near` constraint will also limit results to within 100 miles. #}
{% if platform_name === "Objective-C" %}
{# - iOS 8.0 之后，使用定位服务之前，需要调用 `[locationManager requestWhenInUseAuthorization]` 或 `[locationManager requestAlwaysAuthorization]` 来获取用户的「使用期授权」或「永久授权」，而这两个请求授权需要在 `info.plist` 里面对应添加 `NSLocationWhenInUseUsageDescription` 或 `NSLocationAlwaysUsageDescription` 的键值对，值为开启定位服务原因的描述。SDK 内部默认使用的是「使用期授权」。 #}
{% endif %}

## Users

At the core of many apps, there is a notion of user accounts that allows users to access their information in a secure manner. We provide a specialized user class called `{{ userObjectName }}` which automatically handles much of the functionality required for user account management in your app.

`{{ userObjectName }}` is a subclass of `{{ baseObjectName }}`. Therefore, all the methods that work for `{{ baseObjectName }}` also work for `{{ userObjectName }}`. The only difference is that `{{ userObjectName }}` has some additional features specific to user accounts. Each app has a dedicated `_User` class for storing `{{ userObjectName }}`.

### User Properties

`{{ userObjectName }}` offers the following fields that `{{ baseObjectName }}` does not have:

- `username`: The username of the user.
- `password`: The password of the user.
- `email`: The email address of the user.
- `emailVerfied`: Whether the user has verified the email address with LeanCloud or not.
- `mobilePhoneNumber`: The mobile phone number of the user.
- `mobilePhoneVerfied`: Whether the user has verified the mobile phone number with LeanCloud or not.

We'll go through each of these in detail as we run through the various use cases for users.

### Signing up

When a user first opens your app, you may want them to sign up for an account. The following code shows a typical sign-up process with username and password:

{% if platform_name === "Objective-C" %}
```objc
// Create an instance
AVUser *user = [AVUser user];

// Same as [user setObject:@"Tom" forKey:@"username"]
user.username = @"Tom";
user.password = @"cat!@#123";

// Optional
user.email = @"tom@leancloud.rocks";
user.mobilePhoneNumber = @"+19490008888";

// Other fields can be set in the same way as AVObject
[user setObject:@"secret" forKey:@"gender"];

[user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // Sign-up completed
        NSLog(@"User created. objectId: %@", user.objectId);
    } else {
        // Sign-up failed (often because the username is already taken)
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// Create an instance
var user = new AV.User();

// Same as user.set('username', 'Tom')
user.setUsername('Tom');
user.setPassword('cat!@#123');

// Optional
user.setEmail('tom@leancloud.rocks');
user.setMobilePhoneNumber('+19490008888');

// Other fields can be set in the same way as AV.Object
user.set('gender', 'secret');

user.signUp().then(function (user) {
  // Sign-up completed
  console.log('User created. objectId: ' + user.id);
}, function (error) {
  // Sign-up failed (often because the username is already taken)
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# Create an instance
user = leancloud.User()

# Same as user.set('username', 'Tom')
user.set_username('Tom')
user.set_password('cat!@#123')

# Optional
user.set_email('tom@leancloud.rocks')
user.set_mobile_phone_number('+19490008888')

# Other fields can be set in the same way as leancloud.Object
user.set('gender', 'secret')

user.sign_up()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// Create an instance
$user = new User();

// Same as $user->set("username", "Tom")
$user->setUsername("Tom");
$user->setPassword("cat!@#123");

// Optional
$user->setEmail("tom@leancloud.rocks");
$user->setMobilePhoneNumber("+19490008888");

// Other fields can be set in the same way as LeanObject
$user->set("gender", "secret");

$user->signUp();
```
{% endif %}
{% if platform_name === "Java" %}
```java
// Create an instance
AVUser user = new AVUser();

// Same as user.put("username", "Tom")
user.setUsername("Tom");
user.setPassword("cat!@#123");

// Optional
user.setEmail("tom@leancloud.rocks");
user.setMobilePhoneNumber("+19490008888");

// Other fields can be set in the same way as AVObject
user.put("gender", "secret");

user.signUpInBackground().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Sign-up completed
        System.out.println("User created. objectId: " + user.getObjectId());
    }
    public void onError(Throwable throwable) {
        // Sign-up failed (often because the username is already taken)
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let user = LCUser()

    // Same as user.set("username", value: "Tom")
    user.username = LCString("Tom")
    user.password = LCString("cat!@#123")

    // Optional
    user.set("email", value: "tom@leancloud.rocks")
    user.set("mobilePhoneNumber", value: "+19490008888")

    // Other fields can be set in the same way as LCObject
    user.set("gender", value: "secret")

    try user.set("gender", value: "secret")

    _ = user.signUp { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% call docs.noteWrap() %}
A new `{{ userObjectName }}` should always be created using `{% if platform_name === "Objective-C" %}signUpInBackground{% endif %}{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Java" %}signUpInBackground{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}` rather than `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}`. Subsequent updates to a user can be done with `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}`.
{% endcall %}

If the code returns the error `202`, it means that a user with the same `username` already exists in `_User` table and the client should prompt the user to try a different username. It is also required that each `email` or `mobilePhoneNumber` appears only once in the corresponding column, otherwise error `203` or `214` will occur. You may ask a user to sign up with an email address and make the `username` to be the same as the `email`. By doing so, the user can directly [reset their password with email](#resetting-passwords).

{% call docs.noteWrap() %}
When creating a user with username and password, the SDK sends the password to the cloud in plaintext through HTTPS and the password will be hashed once it arrives to the cloud. (The cloud has no restrictions on password length and complexity.) We never store passwords in plaintext, nor will we ever transmit passwords back to the client in plaintext. Our hashing algorithm guarantees that the original password cannot be retrieved by [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) attack and even app developers themselves will not be able to see the password. Keep in mind that **the password should not be hashed by the client, or the [password reset function](#resetting-passwords) will not work**.
{% endcall %}

#### Signing up with Phones

For a mobile app, it's also common to ask users to sign up with their phone numbers instead of usernames and passwords. There are two basic steps in it. First, ask the user to enter a phone number that can receive text messages. When the user clicks on the "Get Verification Code" button, call the following method to have a 6-digit verification code sent to the phone number the user just entered:

{% if platform_name === "Objective-C" %}
```objc
[AVOSCloud requestSmsCodeWithPhoneNumber:@"+19490008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.Cloud.requestSmsCode('+19490008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.cloudfunc.request_sms_code('+19490008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+19490008888");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestLoginSmsCodeInBackground("+19490008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCSMSClient.requestVerificationCode(mobilePhoneNumber: "+19490008888") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

After the verification code is entered by the user, call the following method to finish signing up:

{% if platform_name === "Objective-C" %}
```objc
[AVUser signUpOrLoginWithMobilePhoneNumberInBackground:@"+19490008888" smsCode:@"123456" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Sign-up completed
        NSLog(@"User created. objectId: %@", user.objectId);
    } else {
        // Verification code is incorrect
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithMobilePhone('+19490008888', '123456').then(function (user) {
  // Sign-up completed
  console.log('User created. objectId: ' + user.id);
}, function (error) {
  // Verification code is incorrect
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.signup_or_login_with_mobile_phone('+19490008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+19490008888", "123456");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground("+19490008888", "123456").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Sign-up completed
        System.out.println("User created. objectId: " + user.getObjectId());
    }
    public void onError(Throwable throwable) {
        // Verification code is incorrect
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCSMSClient.verifyMobilePhoneNumber("+19490008888", verificationCode: "123456", completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}

{% call docs.noteWrap() %}
The `username` will be the same as `mobilePhoneNumber`. The `password` will be a temporary one generated by LeanCloud.
{% endcall %}

#### Phone Number Format

A phone number that `{{ userObjectName }}` accepts should have a leading plus sign (`+`) immediately followed by the country code and the phone number without any dashes, spaces, or other non-numeric characters. For instance, `+8618200008888` is a valid China number (`86` is the country code) and `+19490008888` is a valid US or Canada number (`1` is the country code).

For a list of countries and regions that LeanCloud can reach out through SMS, please refer to the [Pricing](sms-guide.html#pricing) section of the SMS guide.

### Logging in

The code below logs a user in with username and password:

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithUsernameInBackground:@"Tom" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Logged in successfully
    } else {
        // Failed to log in (the password may be incorrect)
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logIn('Tom', 'cat!@#123').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Failed to log in (the password may be incorrect)
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login(username='Tom', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.logIn("Tom", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Logged in successfully
    }
    public void onError(Throwable throwable) {
        // Failed to log in (the password may be incorrect)
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

#### Logging in with Emails

The code below logs a user in with email and password:

{% if platform_name === "Objective-C" %}
```objc
[AVUser loginWithEmail:@"tom@leancloud.rocks" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Logged in successfully
    } else {
        // Failed to log in (the password may be incorrect)
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginWithEmail('tom@leancloud.rocks', 'cat!@#123').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Failed to log in (the password may be incorrect)
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login(email='tom@leancloud.rocks', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithEmail("tom@leancloud.rocks", "cat!@#123");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.loginByEmail("tom@leancloud.rocks", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Logged in successfully
    }
    public void onError(Throwable throwable) {
        // Failed to log in (the password may be incorrect)
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(email: "tom@leancloud.rocks", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

#### Logging in with Phones

If you are allowing users to sign up with their phone numbers, you can also let them log in with either a password or a verification code sent via text message. The code below logs a user in with phone number and password:

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithMobilePhoneNumberInBackground:@"+19490008888" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Logged in successfully
    } else {
        // Failed to log in (the password may be incorrect)
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhone('+19490008888', 'cat!@#123').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Failed to log in (the password may be incorrect)
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login_with_mobile_phone('+19490008888', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithMobilePhoneNumber("+19490008888", "cat!@#123");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.loginByMobilePhoneNumber("+19490008888", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Logged in successfully
    }
    public void onError(Throwable throwable) {
        // Failed to log in (the password may be incorrect)
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+19490008888", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
By default, LeanCloud allows a user to log in to their account as long as the phone number and the password are correct even when the ownership of the phone hasn't been [verified](#verifying-phone-numbers). To make your app more secure, you can choose to allow only those who have their phones verified to log in. The option can be found in [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf).
{% endcall %}

You may also let a user in with a verification code sent to their phone, which is useful when the user forgets the password and does not want to reset it at the moment. Similar to the steps of [signing a user up with phone numbers](#signing-up-with-phones), ask the user to enter the phone number associated with the account, and call the following method once the user clicks on the "Get Verification Code" button:

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestLoginSmsCode:@"+19490008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestLoginSmsCode('+19490008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_login_sms_code('+19490008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+19490008888");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestLoginSmsCodeInBackground("+19490008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestLoginVerificationCode(mobilePhoneNumber: "+19490008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

After the verification code is entered by the user, call the following method to finish logging in:

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithMobilePhoneNumberInBackground:@"+19490008888" smsCode:@"123456" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Logged in successfully
    } else {
        // Verification code is incorrect
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhoneSmsCode('+19490008888', '123456').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Verification code is incorrect
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.signup_or_login_with_mobile_phone('+19490008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+19490008888", "123456");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground("+19490008888", "123456").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Logged in successfully
    }
    public void onError(Throwable throwable) {
        // Verification code is incorrect
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+19490008888", verificationCode: "123456") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

#### Sandbox Phone Number

During the development of your application, you may need to test the sign-up or log-in related API intensively with your phone. As there are, however, limits to how quickly messages can be sent into the carrier networks, your testing pace can be greatly affected.

To work around it, you can set up a sandbox phone number in [Dashboard > Messaging > SMS > Settings](https://console.leancloud.app/messaging.html?appid={{appid}}#/message/sms/conf). LeanCloud will issue a fixed verification code to go with that sandbox phone number. Whenever LeanCloud detects such combination of data, the user will be let right in authenticated without any connections to the carrier networks being made.

On a related note, a sandbox phone number also comes in handy for iOS apps that allow users to log in with SMS code. This is because Apple may ask developers to provide a fixed combination of phone number and verification code for them to review the app as a normal user. Failure to do so may result in their app being rejected by App Store.

For more details regarding limitations of sending and receiving SMS messages, see [SMS Guide](sms-guide.html).

#### Single Device Sign-on

In some scenarios you may want to restrict a user's account to be logged on by no more than one device at a time, that is, when a user logs in to the app on a new device, all the previous sessions on other devices will become invalid. Here's the instruction about how you can implement this feature with LeanCloud:

1. Create a new class that keeps track of each user's credentials and their device information.
2. Each time when a user logs in on a device, update the device information of this user to be the current device.
3. When the app running on another device is opened, check if the device matches the one stored in the cloud. If it does not, [log the user out](#current-user).

#### User Account Lockout

If the wrong password or verification code is entered for an account for more than 6 times within 15 minutes, the account will be disabled temporarily and the error `{ "code": 1, "error": "You have exceeded the maximum number of login attempts, please try again later, or consider resetting your password." }` will be returned.

The account will be automatically recovered 15 minutes after the last attempt and the process cannot be expedited through SDK or REST API. While the account is disabled, the user cannot be logged in even though the correct credentials are provided. The restriction applies to both client-side SDKs and LeanEngine.

### Verifying Emails

You can request that your users have their email addresses verified before they can log in or access certain functions in your app. This makes it harder for spam users to abuse your app. By default, each user has an `emailVerified` field which becomes `false` when the user first signs up or has their email address changed. In your app's [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf), you can enable **Send verification emails when users register or change email addresses from clients** so that when a user signs up or changes their email address, an email containing a verification link will be sent out automatically. You can find the option to prevent users with unverified email addresses from logging in on the same page.

If a user forgets to click on the link and needs to have their account verified later, the following code can be used to send a new email:

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestEmailVerify:@"tom@leancloud.rocks"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestEmailVerify('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_email_verify('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestEmailVerify("tom@leancloud.rocks");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestEmailVerifyInBackground("tom@leancloud.rocks").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationMail(email: "tom@leancloud.rocks") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

The `emailVerified` will become `true` after the link is clicked on. This field can never be `true` when the `email` field is empty.

### Verifying Phone Numbers

Similar to [Verifying Emails](#verifying-emails), you can also request that your users have their phone numbers verified before they can log in or access certain functions in your app. By default, each user has a `mobilePhoneVerified` field which becomes `false` when the user first signs up or has their phone number changed. In your app's [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf), you can enable **Send verification SMS when users register or change phone numbers from clients** so that when a user signs up or changes their phone number, a text message containing a verification code will be sent out automatically. You can find the option to prevent users with unverified phone numbers from logging in on the same page.

You can also initiate a verification request at anytime with the following code:

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestMobilePhoneVerify:@"+19490008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestMobilePhoneVerify('+19490008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_mobile_phone_verify('+19490008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestMobilePhoneVerify("+19490008888");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestMobilePhoneVerifyInBackground("+19490008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationCode(mobilePhoneNumber: "+19490008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

After the verification code is entered by the user, call the following method and the user's `mobilePhoneVerified` will become `true`:

{% if platform_name === "Objective-C" %}
```objc
[AVUser verifyMobilePhone:@"123456" block:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // mobilePhoneVerified is set to true
    } else {
        // Verification code is incorrect
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.verifyMobilePhone('123456').then(function () {
  // mobilePhoneVerified is set to true
}, function (error) {
  // Verification code is incorrect
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.verify_mobile_phone_number('123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::verifyMobilePhone("123456");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.verifyMobilePhoneInBackground("123456").subscribe(new Observer<AVNull>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVNull null) {
        // mobilePhoneVerified is set to true
    }
    public void onError(Throwable throwable) {
        // Verification code is incorrect
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.verifyMobilePhoneNumber(mobilePhoneNumber: "+19490008888", verificationCode: "123456") { result in
    switch result {
    case .success:
        // mobilePhoneVerified is set to true
        break
    case .failure(error: let error):
        // Verification code is incorrect
        print(error)
    }
}
```
{% endif %}

{# ### CAPTCHA Code

Using [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) is a common and effective practice to protest your application from spam and abuse. CAPTCHA offers more than just spam protection. It also helps  reduce fraud and associated costs by blocking bots that could trigger bulk SMS sending.   

LeanCloud CAPTCHA aims to keep bots or other automated software from engaging in abusive activities while letting your valid users pass through with ease.

LeanCloud offers CAPTCHA as a free service to make your app's more bot-proof. #}

### Current User

After a user is logged in, LeanCloud SDK automatically stores the session information of this user in the client so that the user does not need to log in each time they open the client. The following code checks if there is a user logged in:

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
if (currentUser != nil) {
    // Redirect to the home page
} else {
    // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
if (currentUser) {
  // Redirect to the home page
} else {
  // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
current_user = leancloud.User.get_current()
if current_user is not None:
    # Redirect to the home page
    pass
else:
    # Show the sign-up or log-in page
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$currentUser = User::getCurrentUser();
if ($currentUser != null) {
    // Redirect to the home page
} else {
    // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser currentUser = AVUser.getCurrentUser();
if (currentUser != null) {
    // Redirect to the home page
} else {
    // Show the sign-up or log-in page
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let currentUser = LCApplication.default.currentUser
```
{% endif %}

The session information of a user will remain in the client until the user is logged out:

{% if platform_name === "Objective-C" %}
```objc
[AVUser logOut];

// currentUser becomes nil
AVUser *currentUser = [AVUser currentUser];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logOut();

// currentUser becomes null
var currentUser = AV.User.current();
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.logout()

# current_user becomes None
current_user = leancloud.User.get_current()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logOut();

// currentUser becomes null
$currentUser = User::getCurrentUser();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.logOut();

// currentUser becomes null
AVUser currentUser = AVUser.getCurrentUser();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.logOut()

// currentUser becomes nil
let currentUser = LCApplication.default.currentUser
```
{% endif %}

### Setting The Current User

A **session token** will be returned to the client after a user is logged in. It will be cached by our SDK and will be used for authenticating requests made by the same `{{ userObjectName }}` in the future. The session token will be included in the header of each HTTP request made from the client, which helps the cloud identify the `{{ userObjectName }}` sending the request.

Below are the situations when you may need to log a user in with session token:

- A session token is already cached on the client which can be used to automatically log the user in (you can use `{% if platform_name === "Objective-C" %}{# TODO #}{% endif %}{% if platform_name === "JavaScript" %}AV.User.current().getSessionToken(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current().get_session_token(){% endif %}{% if platform_name === "PHP" %}User::getCurrentSessionToken(){% endif %}{% if platform_name === "Java" %}AVUser.getCurrentUser().getSessionToken(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser?.sessionToken{% endif %}` to get the session token of the current user).
- A WebView within the app needs to know the current user.
- The user is logged in on the server side using your own authentication routines and the server is able to provide the session token to the client.

The code below logs a user in with session token (the session token will be validated before proceeding):

{% if platform_name === "Objective-C" %}
```objc
[AVUser becomeWithSessionTokenInBackground:@"anmlwi96s381m6ca7o7266pzf" block:^(AVUser * _Nullable user, NSError * _Nullable error) {
    if (user != nil) {
        // Logged in successfully
    } else {
        // Session token is invalid
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.become('anmlwi96s381m6ca7o7266pzf').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Session token is invalid
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.become('anmlwi96s381m6ca7o7266pzf')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::become("anmlwi96s381m6ca7o7266pzf");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.becomeWithSessionTokenInBackground("anmlwi96s381m6ca7o7266pzf").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Logged in successfully
    }
    public void onError(Throwable throwable) {
        // Session token is invalid
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(sessionToken: "anmlwi96s381m6ca7o7266pzf") { (result) in
    switch result {
    case .success(object: let user):
        // Logged in successfully
        print(user)
    case .failure(error: let error):
        // Session token is invalid
        print(error)
    }
}
```
{% endif %}

{% call docs.alertWrap() %}
For security reasons, please avoid passing session tokens as a part of URLs in non-private environments. This increases the risk that they will be captured by attackers.
{% endcall %}

{% call docs.noteWrap() %}
If **Log out the user when password is updated** is checked on in [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf), the session token of a user will be reset in the cloud after this user changes the password and the client needs to prompt the user to log in again, otherwise [`403 (Forbidden)`](error_code.html#_403) will be returned as an error.
{% endcall %}

The code below checks if a session token is valid:

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
NSString *token = currentUser.sessionToken;
[currentUser isAuthenticatedWithSessionToken:token callback:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
        // The session token is valid
    } else {
        // The session token is invalid
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
currentUser.isAuthenticated().then(function (authenticated) {
  if (authenticated) {
    // The session token is valid
  } else {
    // The session token is invalid
  }
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
authenticated = leancloud.User.get_current().is_authenticated()
if authenticated:
    # The session token is valid
    pass
else:
    # The session token is invalid
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$authenticated = User::isAuthenticated();
if ($authenticated) {
    // The session token is valid
} else {
    // The session token is invalid
}
```
{% endif %}
{% if platform_name === "Java" %}
```java
boolean authenticated = AVUser.getCurrentUser().isAuthenticated();
if (authenticated) {
    // The session token is valid
} else {
    // The session token is invalid
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}

### Resetting Passwords

It's quite common for the users of an app to forget their passwords. LeanCloud provides a number of ways for them to reset their passwords.

Here is the flow of resetting password with email:

1. The user enters the email address used for the account.
2. LeanCloud sends an email to the address including a link for resetting password.
3. After the user clicks on the link, a new page will pop up, asking for a new password.
4. The password will be reset after the user enters a new password.

To start with, ask the user to enter the email used for the account, and call the function below:

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestPasswordResetForEmailInBackground:@"tom@leancloud.rocks"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordReset('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordReset("tom@leancloud.rocks");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestPasswordResetInBackground("tom@leancloud.rocks").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(email: "tom@leancloud.rocks") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

The code above will check if there is a user in the `_User` table that has the `email` to be the same as the one provided, and will send them a password reset email if so. As mentioned previously, you can make the `username` of each user to be the same as their `email`, or collect the email separately and store it in the `email` field.

{% call docs.noteWrap() %}
The content of the password reset email is fully customizable. You can go to your app's [Dashboard > Settings > Email templates](https://console.leancloud.app/app.html?appid={{appid}}#/email) and modify the corresponding template.
{% endcall %}

Alternatively, you can ask for the mobile phone number instead of the email to reset their password:

1. The user enters the mobile phone number used for the account.
2. LeanCloud sends a short message to the number including a verification code.
3. The user types in the verification code and a new password.

The code below sends a verification code to a number:

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestPasswordResetWithPhoneNumber:@"+19490008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordResetBySmsCode('+19490008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset_by_sms_code('+19490008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordResetBySmsCode("+19490008888");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.requestPasswordResetBySmsCodeInBackground("+19490008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(mobilePhoneNumber: "+19490008888") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

The code above will check if there is a user in the `_User` table that has the `mobilePhoneNumber` to be the same as the one provided, and will send them a verification code if so.

{% call docs.noteWrap() %}
By changing the settings in [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf), you can restrict the use of the mobile phone number for the above flow only if the `mobilePhoneVerified` field is `true`.
{% endcall %}

The code below resets the password of a user after they enter the verification code and a new password:

{% if platform_name === "Objective-C" %}
```objc
[AVUser resetPasswordWithSmsCode:@"123456" newPassword:@"cat!@#123" block:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // Password is updated
    } else {
        // Verification code is incorrect
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.resetPasswordBySmsCode('123456', 'cat!@#123').then(function () {
  // Password is updated
}, function (error) {
  // Verification code is incorrect
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.reset_password_by_sms_code('123456', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::resetPasswordBySmsCode("123456", "cat!@#123");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.resetPasswordBySmsCodeInBackground("123456", "cat!@#123").subscribe(new Observer<AVNull>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVNull null) {
        // Password is updated
    }
    public void onError(Throwable throwable) {
        // Verification code is incorrect
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.resetPassword(mobilePhoneNumber: "+19490008888", verificationCode: "123456", newPassword: "cat!@#123") { result in
    switch result {
    case .success:
        // Password is updated
        break
    case .failure(error: let error):
        // Verification code is incorrect
        print(error)
    }
}
```
{% endif %}

{# > Note that the messaging in either of the above flows will reference your app by the name that you specified when you created this app on LeanCloud. #}

### Queries on Users

To query for users, you can simple create a new `{{ baseQueryClassName }}` for `_User`:

{% if platform_name === "Objective-C" %}
```objc
AVQuery *userQuery = [AVUser query];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var userQuery = new AV.Query('_User');
```
{% endif %}
{% if platform_name === "Python" %}
```python
user_query = leancloud.Query('_leancloud.User')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$userQuery = new Query("_User");
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVQuery<AVUser> userQuery = AVUser.getQuery();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let userQuery = LCQuery(className: "_User")
```
{% endif %}

For security reasons, **the `_User` table of each new app has its `find` permission disabled by default**. Each user can only access their own data in `_User` table and cannot access that of others. If you need to allow each user to view other users' data, we recommend that you create a new table to store such data and enable the `find` permission of this table. You may also encapsulate queries on users within [LeanEngine](leanengine_overview.html) and avoid opening up `find` permissions of `_User` tables.

See [Security of User Objects](#security-of-user-objects) for other restrictions applied to the `_User` table, and [Data and Security](data_security.html) for more information regarding class-level permission settings.

### Associations

Associations involving `{{ userObjectName }}` works in the same way as basic `{{ baseObjectName }}`. The code below saves a new book for an author and retrieves all the books written by that author:

{% if platform_name === "Objective-C" %}
```objc
AVObject *book = [AVObject objectWithClassName:@"Book"];
AVUser *author = [AVUser currentUser];
[book setObject:@"My Fifth Book" forKey:@"title"];
[book setObject:author forKey:@"author"];
[book saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    // Find all the books by the same author
    AVQuery *query = [AVQuery queryWithClassName:@"Book"];
    [query whereKey:@"author" equalTo:author];
    [query findObjectsInBackgroundWithBlock:^(NSArray *books, NSError *error) {
        // books is an array of Book objects by the same author
    }];
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var Book = AV.Object.extend('Book');
var book = new Book();
var author = AV.User.current();
book.set('title', 'My Fifth Book');
book.set('author', author);
book.save().then(function (book) {
  // Find all the books by the same author
  var query = new AV.Query('Book');
  query.equalTo('author', author);
  query.find().then(function (books) {
    // books is an array of Book objects by the same author
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Book = leancloud.Object.extend('Book')
book = Book()
author = leancloud.User.get_current()
book.set('title', 'My Fifth Book')
book.set('author', author)
book.save()

# Find all the books by the same author
query = Book.query
query.equal_to('author', author)
book_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$book = new LeanObject("Book");
$author = User::getCurrentUser();
$book->set("title", "My Fifth Book");
$book->set("author", $author);
$book->save();

// Find all the books by the same author
$query = new Query("Book");
$query->equalTo("author", $author);
$books = $query->find();
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVObject book = new AVObject("Book");
AVUser author = AVUser.getCurrentUser();
book.put("title", "My Fifth Book");
book.put("author", author);
book.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject book) {
        // Find all the books by the same author
        AVQuery<AVObject> query = new AVQuery<>("Book");
        query.whereEqualTo("author", author);
        query.findInBackground().subscribe(new Observer<List<AVObject>>() {
            public void onSubscribe(Disposable disposable) {}
            public void onNext(List<AVObject> books) {
                // books is an array of Book objects by the same author
            }
            public void onError(Throwable throwable) {}
            public void onComplete() {}
        });
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    guard let author = LCApplication.default.currentUser else {
        return
    }
    let book = LCObject(className: "Book")
    let author = LCApplication.default.currentUser
    try book.set("title", value: "My Fifth Book")
    try book.set("author", value: author)
    _ = book.save { result in
        switch result {
        case .success:
            // Find all the books by the same author
            let query = LCQuery(className: "Book")
            query.whereKey("author", .equalTo(author))
            _ = query.find { result in
                switch result {
                case .success(objects: let books):
                    // books is an array of Book objects by the same author
                    break
                case .failure(error: let error):
                    print(error)
                }
            }
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

### Security of User Objects

The `{{ userObjectName }}` class is secured by default. You are not able to invoke any save- or delete-related methods unless the `{{ userObjectName }}` was obtained using an authenticated method like `{% if platform_name === "Objective-C" %}logInWithUsername{% endif %}{% if platform_name === "JavaScript" %}logIn{% endif %}{% if platform_name === "Python" %}login{% endif %}{% if platform_name === "PHP" %}logIn{% endif %}{% if platform_name === "Java" %}logIn{% endif %}{% if platform_name === "Swift" %}logIn{% endif %}` or `{% if platform_name === "Objective-C" %}signUpInBackground{% endif %}{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Java" %}signUpInBackground{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}`. This ensures that each user can only update their own data.

The reason behind is that most data stored in `{{ userObjectName }}` can be very personal and sensitive, such as mobile phone number, social network account ID, etc. Even the app's owner should avoid tampering with these data for the sake of user's privacy.

The code below illustrates this security policy:

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithUsernameInBackground:@"Tom" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // Attempt to change username
        [user setObject:@"Jerry" forKey:@"username")];
        // Password is hashed and an empty string will be returned
        NSString *password = user[@"password"];
        // Save changes
        [user saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
            if (succeeded) {
                // This will work since the user is authenticated

                // Get the user with a non-authenticated method
                AVQuery *query = [AVQuery queryWithClassName:@"_User"]; 
                [query getObjectInBackgroundWithId:user.objectId block:^(AVObject *unauthenticatedUser, NSError *error) {
                    [unauthenticatedUser setObject:@"Toodle" forKey:@"username"];
                    [unauthenticatedUser saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
                        if (succeeded) {
                            // This will not succeed since the user is unauthenticated
                        } else {
                            // Failure is expected
                        }
                    }];
                }];
            } else {
                // Error handling
            }
        }];
    } else {
        // Error handling
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var user = AV.User.logIn('Tom', 'cat!@#123').then(function (user) {
  // Attempt to change username
  user.set('username', 'Jerry');
  // Password is hashed and an empty string will be returned
  var password = user.get('password');
  // Save changes
  user.save().then(function (user) {
    // This will work since the user is authenticated

    // Get the user with a non-authenticated method
    var query = new AV.Query('_User');
    query.get(user.objectId).then(function (unauthenticatedUser) {
      unauthenticatedUser.set('username', 'Toodle');
      unauthenticatedUser.save().then(function (unauthenticatedUser) { }, function (error) {
        // This will cause error since the user is unauthenticated
      });
    });
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login('Tom', 'cat!@#123')
current_user = leancloud.User.get_current()

# Attempt to change username
current_user.set('username', 'Jerry')
# Password is hashed and an empty string will be returned
password = current_user.get('password')
# This will work since the user is authenticated
current_user.save()

# Get the user with a non-authenticated method
query = leancloud.Query('_User')
unauthenticated_user = query.get(current_user.id)
unauthenticated_user.set('username', 'Toodle')
# This will cause error since the user is unauthenticated
unauthenticated_user.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
$currentUser = User::getCurrentUser();

// Attempt to change username
$currentUser->set("username", "Jerry");
// Password is hashed and an empty string will be returned
$password = $currentUser->get("password");
// This will work since the user is authenticated
$currentUser->save();

// Get the user with a non-authenticated method
$query = new Query("_User");
$unauthenticatedUser = $query->get($currentUser->getObjectId())
$unauthenticatedUser->set("username", "Toodle");
// This will cause error since the user is unauthenticated
$unauthenticatedUser->save()
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.logIn("Tom", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // Attempt to change username
        user.put("username", "Jerry");
        // Password is hashed and an empty string will be returned
        String password = user.getString("password");
        // This will work since the user is authenticated
        user.save();

        // Get the user with a non-authenticated method
        AVQuery<AVUser> query = new AVQuery<>("_User");
        query.getInBackground(user.getObjectId()).subscribe(new Observer<AVUser>() {
            public void onSubscribe(Disposable disposable) {}
            public void onNext(AVUser unauthenticatedUser) {
                unauthenticatedUser.put("username", "Toodle");
                // This will cause error since the user is unauthenticated
                unauthenticatedUser.save();
            }
            public void onError(Throwable throwable) {}
            public void onComplete() {}
        });
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        // Attempt to change username
        try! user.set("username", "Jerry")
        // Password is hashed and an empty string will be returned
        let password = user.get("password")
        // This will work since the user is authenticated
        user.save()

        // Get the user with a non-authenticated method
        let query = LCQuery(className: "_User")
        _ = query.get(user.objectId) { result in
            switch result {
                case .success(object: let unauthenticatedUser):
                    try! unauthenticatedUser.set("username", "Toodle")
                    _ = unauthenticatedUser.save { result in
                        switch result {
                            .success:
                                // This will not succeed since the user is unauthenticated
                            .failure:
                                // Failure is expected
                        }
                    }
                case .failure(error: let error):
                    print(error)
            }
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

The `{{ userObjectName }}` obtained from `{% if platform_name === "Objective-C" %}[AVUser currentUser]{% endif %}{% if platform_name === "JavaScript" %}AV.User.current(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current(){% endif %}{% if platform_name === "PHP" %}User::getCurrentUser(){% endif %}{% if platform_name === "Java" %}AVUser.getCurrentUser(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser{% endif %}` will always be authenticated.

To check if `{{ userObjectName }}` is authenticated, you can invoke the `{% if platform_name === "Objective-C" %}isAuthenticatedWithSessionToken{% endif %}{% if platform_name === "JavaScript" %}isAuthenticated{% endif %}{% if platform_name === "Python" %}is_authenticated{% endif %}{% if platform_name === "PHP" %}isAuthenticated{% endif %}{% if platform_name === "Java" %}isAuthenticated{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}` method. You do not need to check if `{{ userObjectName }}` is authenticated if it is obtained via an authenticated method.

As a reminder, the user's password can be set when signing up but cannot be modified and saved to the cloud afterwards unless the user requests it to be [reset](#resetting-passwords). It will not be cached on the client and will show as `null` when being retrieved from the cloud after the user is logged in.

### Security of Other Objects

For each given object, you can specify which users are allowed to read it and which are allowed to modify it. To support this type of security, each object has an [access control list](http://en.wikipedia.org/wiki/Access_control_list), implemented by the `{% if platform_name === "Objective-C" %}AVACL{% endif %}{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Java" %}AVACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}` class. More details can be found in [ACL Guide](acl-guide.html).

### Linking Users

LeanCloud allows you to link your users with services like GitHub, Twitter, and Facebook (commonly known as social networking services, or SNS), allowing your users to sign up or log into your application using their existing identities. For example, to sign up or log in with a user's GitHub account, your code will look like this:

{% if platform_name === "Objective-C" %}
{# TODO #}
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var authData = {
  // Required
  uid:           'UID',
  access_token:  'ACCESS_TOKEN',
  expires_in:    7200,

  // Optional
  refresh_token: 'REFRESH_TOKEN',
  scope:         'SCOPE'
};
AV.User.loginWithAuthData(authData, 'github').then(function (user) {
  // Logged in successfully
}, function (error) {
  // Failed to log in
});
```
{% endif %}
{% if platform_name === "Python" %}
{# TODO #}
{% endif %}
{% if platform_name === "PHP" %}
{# TODO #}
{% endif %}
{% if platform_name === "Java" %}
Map<String, Object> authData = new HashMap<String, Object>();
// required
authData.put("expires_in", 7200);
authData.put("openid", "OPENID");
authData.put("access_token", "ACCESS_TOKEN");
authData.put("platform", "weixin");
// optional
authData.put("refresh_token", "REFRESH_TOKEN");
authData.put("scope", "SCOPE");
AVUser.loginWithAuthData(authData, "weixin").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser avUser) {
       System.out.println("Logged in successfully.");
    }
    public void onError(Throwable throwable) {
       System.out.println("Failed to log in");
    }
    public void onComplete() {}
});
{% endif %}
{% if platform_name === "Swift" %}
```swift
let authData: [String: Any] = [
    // Required
    "uid":           "UID",
    "access_token":  "ACCESS_TOKEN",
    "expires_in":    7200,

    // Optional
    "refresh_token": "REFRESH_TOKEN",
    "scope":         "SCOPE"
]
let user = LCUser()
user.logIn(authData: authData, platform: .custom("github")) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

LeanCloud then verifies that the provided `authData` is valid and checks if a user is already associated with it. If so, it returns the status code `200 OK` along with the details (including a [`sessionToken`](#setting-the-current-user) for the user).

If the `authData` is not linked to any account, you will instead receive the status code `201 Created`, indicating that a new user has been created. The body of the response contains `objectId`, `createdAt`, `sessionToken`, and an automatically-generated unique `username`. For example:

```json
{
  "username":     "k9mjnl7zq9mjbc7expspsxlls",
  "objectId":     "5b029266fb4ffe005d6c7c2e",
  "createdAt":    "2018-05-21T09:33:26.406Z",
  "updatedAt":    "2018-05-21T09:33:26.575Z",
  "sessionToken": "…",
  // authData won't be returned in most cases
  // See explanations below
  "authData": {
    // …
  }
  // …
}
```

The `authData` field won't be returned to the client unless it is owned by the current user.

To ensure that each `{{ userObjectName }}` is linked to each service account only once, a unique index needs to be created for the `authData.<SERVICE_NAME>.uid` key in the `_User` class.

#### Authentication Data

`authData` is a JSON object with the names of services as keys and the details as values. You are responsible for completing the authentication flow (usually through OAuth 1.0 or 2.0) to obtain the details from the service provider which is required for linking.

A user who has GitHub linked may have the following object as `authData`:

```json
{
  "github": {
    "uid":           "…",
    "access_token":  "…",
    "expires_in":    7200,
    "refresh_token": "…",
    "scope":         "…"
  }
}
```

LeanCloud automatically validates the access tokens for certain services to prevent data forge attack. When the validation fails, LeanCloud will respond with `invalid authData` error and the linking will not be established. For services that are not recognized by LeanCloud, you are responsible for validating access tokens by yourself. You can turn off the **Validate access tokens when logging in with third-party accounts** option in your app's [Dashboard > LeanStorage > Settings](https://console.leancloud.app/storage.html?appid={{appid}}#/storage/conf) if you prefer not to have LeanCloud validate access tokens for you.

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Swift" %}
{# #### 扩展需求 #}
{% endif %}

#### Unlinking

You can unlink a service by setting the `authData` for the service to `null`. The code below unlinks a user's GitHub account:

{% if platform_name === "Objective-C" %}
{# TODO #}
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginWithAuthData(null, 'github').then(function (s) {
  // Unlinked successfully
}, function (error) {
  // Failed to unlink
});
```
{% endif %}
{% if platform_name === "Python" %}
{# TODO #}
{% endif %}
{% if platform_name === "PHP" %}
{# TODO #}
{% endif %}
{% if platform_name === "Java" %}
{# TODO #}
{% endif %}
{% if platform_name === "Swift" %}
{# TODO #}
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Java" %}
### Anonymous Users

With the support of anonymous users, you can have your users try the application without signing up or logging in. The code below creates an anonymous user:

{% if platform_name === "Objective-C" %}
```objc
[AVUser loginAnonymouslyWithCallback:^(AVUser *user, NSError *error) {
    // user is the new anonymous user
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginAnonymously().then(function (user) {
  // user is the new anonymous user
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
AVUser.logInAnonymously().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // user is the new anonymous user
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}

You can add new properties or fields to an anonymous user just like with a normal user, such as `username`, `password`, `email`, etc. You can also convert an anonymous user to a normal user by going through the same sign-up process as you do with a normal user. An anonymous user can:

- [Sign up with username and password](#signing-up).
- [Link to a third-party service or platform](#linking-users), such as GitHub.

The code below sets a username and password for an anonymous user:

{% if platform_name === "Objective-C" %}
```objc
// currentUser is the anonymous user
AVUser *currentUser = [AVUser currentUser];

user.username = @"Tom";
user.password = @"cat!@#123";

[user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // currentUser has become a normal user
    } else {
        // Sign-up failed (often because the username is already taken)
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// currentUser is the anonymous user
var currentUser = AV.User.current();

user.setUsername('Tom');
user.setPassword('cat!@#123');

user.signUp().then(function (user) {
  // currentUser has become a normal user
}, function (error) {
  // Sign-up failed (often because the username is already taken)
});
```
{% endif %}
{% if platform_name === "Java" %}
```java
// currentUser is the anonymous user
AVUser currentUser = AVUser.getCurrentUser();

currentUser.setUsername("Tom");
currentUser.setPassword("cat!@#123");

currentUser.signUpInBackground().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // currentUser has become a normal user
    }
    public void onError(Throwable throwable) {
        // Sign-up failed (often because the username is already taken)
    }
    public void onComplete() {}
});
```
{% endif %}

The code below checks if the current user is anonymous:

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
if (currentUser.isAnonymous) {
    // currentUser is anonymous
} else {
    // currentUser is not anonymous
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
if (currentUser.isAnonymous()) {
  // currentUser is anonymous
} else {
  // currentUser is not anonymous
}
```
{% endif %}
{% if platform_name === "Java" %}
```java
{# TODO #}
```
{% endif %}

If an anonymous user is not converted to a normal user before they log out, they will not be able to log in to the same account later and the data stored in that account cannot be retrieved anymore.
{% endif %}

## Roles

As your app grows in scope and user-base, you may find yourself needing more coarse-grained control over access to pieces of your data than user-linked ACLs can provide. To address this requirement, LeanCloud supports a form of role-based access control. Check the detailed [ACL Guide](acl-guide.html) to learn how to set it up for your objects.

{% if platform_name === "Objective-C" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Swift" %}
{# ## 子类化 #}
{% endif %}

## In-App Searching

In-App Searching offers a better way to search through the information contained within your apps. It's built with search engine capabilities that you can easily tap into your app. Effective and useful searching functionality in your app is crucial for helping users find what they need. For more details, see [In-App Searching Guide](app_search_guide.html).

## In-App Socializing

In-app socializing offers features like following, timeline, status update, interaction, messaging, etc. For more details, see [In-App Socializing Guide](status_system.html).

{% if platform_name === "JavaScript" %}
{# ## Push 通知 #}
{% endif %}

{% if platform_name === "JavaScript" %}
## WebView

LeanStorage JavaScript SDK can be used in a WebView like PhoneGap, Cordova, WeChat WebView, etc.

### Android WebView

If you are using Android WebView, the following configurations need to be done when creating WebView in you Native code.

1. Our JS SDK uses `window.localStorage` which means that `localStorage` of WebView needs to be enabled:

   ```java
   yourWebView.getSettings().setDomStorageEnabled(true);
   ```

2. If you wish to debug WebView directly in your mobile devices, remote debugging needs to be configured for generating WebView. Refer to [Google's official documentation](https://developer.chrome.com/devtools/docs/remote-debugging) for more details.

   ```java
   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
     yourWebView.setWebContentsDebuggingEnabled(true);
   }
   ```

   Keep in mind that this method is only supported on Android 4.4 and above.
3. When developing the UI of your app with WebView, Native makes use of Hybrid for the app running on your phone. We recommend that you first design the UI of your app with Chrome Developer Tools. After the UI is done, start working on data binding with Native during which you can debug WebView on your phone with Remote debugger. This will save you a lot of time on developing and debugging. If you choose to develop UI with Remote debugger as well, you will end up spending more time on it.

4. As a security practice to prevent JavaScript from calling Java functions for accessing the file system of an Android device, Android 4.2 and later versions only allow WebView to access the methods exposed by the annotation [`@JavascriptInterface`](http://developer.android.com/reference/android/webkit/JavascriptInterface.html). If you have users using Android 4.2 or above, make sure the annotation is added or `Uncaught TypeError` might be triggered.
{% endif %}
